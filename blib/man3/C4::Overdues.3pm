.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "C4::Overdues 3"
.TH C4::Overdues 3 "2010-12-10" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Circulation::Fines \- Koha module dealing with fines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use C4::Overdues;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module contains several functions for dealing with fines for
overdue items. It is primarily used by the 'misc/fines2.pl' script.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "Getoverdues"
.IX Subsection "Getoverdues"
.Vb 1
\&  $overdues = Getoverdues( { minimumdays => 1, maximumdays => 30 } );
.Ve
.PP
Returns the list of all overdue books, with their itemtype.
.PP
\&\f(CW$overdues\fR is a reference-to-array. Each element is a
reference-to-hash whose keys are the fields of the issues table in the
Koha database.
.SS "GetOverduesByBorrowers"
.IX Subsection "GetOverduesByBorrowers"
\&\f(CW@borrowers\fR = \fIGetOverduesByBorrowers()\fR;
.PP
Returns an array with hashes, that contains all informations of borrowers, and another hash with overdues
.PP
\&\f(CW@borrower\fR = [
    {
        'surname'        => ,
        'firstname'      => ,
        'title'          => ,
        'borrowernumber' => ,
        'address'        => ,
        'city'           => ,
        'zipcode'        => ,
        'phone'          => ,
        'email'          => ,
        'branchcode'     => ,
        'overdues'       => {
            'biblionumber' => ,
            'title'        => ,
            'author'       => ,
            'issuedate'    => ,
            'datedue'      => ,
            'barcode'      => ,
            'itemnumber'   => ,
            'callnumber'   => ,
        }
    }
]
.SS "checkoverdues"
.IX Subsection "checkoverdues"
($count, \f(CW$overdueitems\fR) = checkoverdues($borrowernumber);
.PP
Returns a count and a list of overdueitems for a given borrowernumber
.SS "CalcFine"
.IX Subsection "CalcFine"
.Vb 2
\&  ($amount, $chargename, $daycount, $daycounttotal) =
\&    &CalcFine($item, $categorycode, $branch, $days_overdue, $description, $start_date, $end_date );
.Ve
.PP
Calculates the fine for a book.
.PP
The issuingrules table in the Koha database is a fine matrix, listing
the penalties for each type of patron for each type of item and each branch (e.g., the
standard fine for books might be \f(CW$0\fR.50, but \f(CW$1\fR.50 for DVDs, or staff
members might get a longer grace period between the first and second
reminders that a book is overdue).
.PP
\&\f(CW$item\fR is an item object (hashref).
.PP
\&\f(CW$categorycode\fR is the category code (string) of the patron who currently has
the book.
.PP
\&\f(CW$branchcode\fR is the library (string) whose issuingrules govern this transaction.
.PP
\&\f(CW$days_overdue\fR is the number of days elapsed since the book's due date.
  \s-1NOTE:\s0 supplying days_overdue is deprecated.
.PP
\&\f(CW$start_date\fR & \f(CW$end_date\fR are C4::Dates objects 
defining the date range over which to determine the fine.
Note that if these are defined, we ignore \f(CW$difference\fR and \f(CW$dues\fR , 
but retain these for backwards-comptibility with extant fines scripts.
.PP
Fines scripts should just supply the date range over which to calculate the fine.
.PP
\&\f(CW&CalcFine\fR returns four values:
.PP
\&\f(CW$amount\fR is the fine owed by the patron (see above).
.PP
\&\f(CW$chargename\fR is the chargename field from the applicable record in
the categoryitem table, whatever that is.
.PP
\&\f(CW$daycount\fR is the number of days between start and end dates, Calendar adjusted (where needed), 
minus any applicable grace period.
.PP
\&\f(CW$daycounttotal\fR is \f(CW$daycount\fR without consideration of grace period.
.PP
\&\s-1FIXME\s0 \- What is chargename supposed to be ?
.PP
\&\s-1FIXME:\s0 previously attempted to return \f(CW$message\fR as a text message, either \*(L"First Notice\*(R", \*(L"Second Notice\*(R",
or \*(L"Final Notice\*(R".  But CalcFine never defined any value.
.SS "GetSpecialHolidays"
.IX Subsection "GetSpecialHolidays"
&GetSpecialHolidays($date_dues,$itemnumber);
.PP
return number of special days  between date of the day and date due
.PP
\&\f(CW$date_dues\fR is the envisaged date of book return.
.PP
\&\f(CW$itemnumber\fR is the book's item number.
.SS "GetRepeatableHolidays"
.IX Subsection "GetRepeatableHolidays"
&GetRepeatableHolidays($date_dues, \f(CW$itemnumber\fR, \f(CW$difference\fR,);
.PP
return number of day closed between date of the day and date due
.PP
\&\f(CW$date_dues\fR is the envisaged date of book return.
.PP
\&\f(CW$itemnumber\fR is item number.
.PP
\&\f(CW$difference\fR numbers of between day date of the day and date due
.SS "GetWayFromItemnumber"
.IX Subsection "GetWayFromItemnumber"
&Getwdayfromitemnumber($itemnumber);
.PP
return the different week day from repeatable_holidays table
.PP
\&\f(CW$itemnumber\fR is  item number.
.SS "GetIssuesIteminfo"
.IX Subsection "GetIssuesIteminfo"
&GetIssuesIteminfo($itemnumber);
.PP
return all data from issues about item
.PP
\&\f(CW$itemnumber\fR is  item number.
.SS "UpdateFine"
.IX Subsection "UpdateFine"
.Vb 1
\&  &UpdateFine($itemnumber, $borrowernumber, $amount, $type, $description);
.Ve
.PP
(Note: the following is mostly conjecture and guesswork.)
.PP
Updates the fine owed on an overdue book.
.PP
\&\f(CW$itemnumber\fR is the book's item number.
.PP
\&\f(CW$borrowernumber\fR is the borrower number of the patron who currently
has the book on loan.
.PP
\&\f(CW$amount\fR is the current amount owed by the patron.
.PP
\&\f(CW$type\fR will be used in the description of the fine.
.PP
\&\f(CW$description\fR is a string that must be present in the description of
the fine. I think this is expected to be a date in \s-1DD/MM/YYYY\s0 format.
.PP
\&\f(CW&UpdateFine\fR looks up the amount currently owed on the given item
and sets it to \f(CW$amount\fR, creating, if necessary, a new entry in the
accountlines table of the Koha database.
.SS "BorType"
.IX Subsection "BorType"
.Vb 1
\&  $borrower = &BorType($borrowernumber);
.Ve
.PP
Looks up a patron by borrower number.
.PP
\&\f(CW$borrower\fR is a reference-to-hash whose keys are all of the fields
from the borrowers and categories tables of the Koha database. Thus,
\&\f(CW$borrower\fR contains all information about both the borrower and
category he or she belongs to.
.SS "ReplacementCost"
.IX Subsection "ReplacementCost"
.Vb 1
\&  $cost = &ReplacementCost($itemnumber);
.Ve
.PP
Returns the replacement cost of the item with the given item number.
.SS "GetFine"
.IX Subsection "GetFine"
\&\f(CW$data\fR\->{'sum(amountoutstanding)'} = &GetFine($itemnum,$borrowernumber);
.PP
return the total of fine
.PP
\&\f(CW$itemnum\fR is item number
.PP
\&\f(CW$borrowernumber\fR is the borrowernumber
.SS "GetIssuingRules"
.IX Subsection "GetIssuingRules"
\&\s-1FIXME\s0 \- This sub should be deprecated and removed.
It ignores branch and defaults.
.PP
\&\f(CW$data\fR = &GetIssuingRules($itemtype,$categorycode);
.PP
Looks up for all issuingrules an item info
.PP
\&\f(CW$itemnumber\fR is a reference-to-hash whose keys are all of the fields
from the borrowers and categories tables of the Koha database. Thus,
.PP
\&\f(CW$categorycode\fR contains  information about borrowers category
.PP
\&\f(CW$data\fR contains all information about both the borrower and
category he or she belongs to.
.SS "GetNextIdNotify"
.IX Subsection "GetNextIdNotify"
($result) = &GetNextIdNotify($reference);
.PP
Returns the new file number
.PP
\&\f(CW$result\fR contains the next file number
.PP
\&\f(CW$reference\fR contains the beggining of file number
.SS "NumberNotifyId"
.IX Subsection "NumberNotifyId"
(@notify) = &NumberNotifyId($borrowernumber);
.PP
Returns amount for all file per borrowers
\&\f(CW@notify\fR array contains all file per borrowers
.PP
\&\f(CW$notify_id\fR contains the file number for the borrower number nad item number
.SS "AmountNotify"
.IX Subsection "AmountNotify"
($totalnotify) = &AmountNotify($notifyid);
.PP
Returns amount for all file per borrowers
\&\f(CW$notifyid\fR is the file number
.PP
\&\f(CW$totalnotify\fR contains amount of a file
.PP
\&\f(CW$notify_id\fR contains the file number for the borrower number and item number
.SS "GetNotifyId"
.IX Subsection "GetNotifyId"
($notify_id) = &GetNotifyId($borrowernumber,$itemnumber);
.PP
Returns the file number per borrower and itemnumber
.PP
\&\f(CW$borrowernumber\fR is a reference-to-hash whose keys are all of the fields
from the items tables of the Koha database. Thus,
.PP
\&\f(CW$itemnumber\fR contains the borrower categorycode
.PP
\&\f(CW$notify_id\fR contains the file number for the borrower number nad item number
.SS "CreateItemAccountLine"
.IX Subsection "CreateItemAccountLine"
() = &CreateItemAccountLine($borrowernumber,$itemnumber,$date,$amount,$description,$accounttype,$amountoutstanding,$timestamp,$notify_id,$level);
.PP
update the account lines with file number or with file level
.PP
\&\f(CW$items\fR is a reference-to-hash whose keys are all of the fields
from the items tables of the Koha database. Thus,
.PP
\&\f(CW$itemnumber\fR contains the item number
.PP
\&\f(CW$borrowernumber\fR contains the borrower number
.PP
\&\f(CW$date\fR contains the date of the day
.PP
\&\f(CW$amount\fR contains item price
.PP
\&\f(CW$description\fR contains the descritpion of accounttype
.PP
\&\f(CW$accounttype\fR contains the account type
.PP
\&\f(CW$amountoutstanding\fR contains the \f(CW$amountoutstanding\fR
.PP
\&\f(CW$timestamp\fR contains the timestamp with time and the date of the day
.PP
\&\f(CW$notify_id\fR contains the file number
.PP
\&\f(CW$level\fR contains the file level
.SS "UpdateAccountLines"
.IX Subsection "UpdateAccountLines"
() = &UpdateAccountLines($notify_id,$notify_level,$borrowernumber,$itemnumber);
.PP
update the account lines with file number or with file level
.PP
\&\f(CW$items\fR is a reference-to-hash whose keys are all of the fields
from the items tables of the Koha database. Thus,
.PP
\&\f(CW$itemnumber\fR contains the item number
.PP
\&\f(CW$notify_id\fR contains the file number
.PP
\&\f(CW$notify_level\fR contains the file level
.PP
\&\f(CW$borrowernumber\fR contains the borrowernumber
.SS "GetItems"
.IX Subsection "GetItems"
($items) = &GetItems($itemnumber);
.PP
Returns the list of all delays from overduerules.
.PP
\&\f(CW$items\fR is a reference-to-hash whose keys are all of the fields
from the items tables of the Koha database. Thus,
.PP
\&\f(CW$itemnumber\fR contains the borrower categorycode
.SS "GetOverdueDelays"
.IX Subsection "GetOverdueDelays"
(@delays) = &GetOverdueDelays($categorycode);
.PP
Returns the list of all delays from overduerules.
.PP
\&\f(CW@delays\fR it's an array contains the three delays from overduerules table
.PP
\&\f(CW$categorycode\fR contains the borrower categorycode
.SS "GetBranchcodesWithOverdueRules"
.IX Subsection "GetBranchcodesWithOverdueRules"
.RS 4
my \f(CW@branchcodes\fR = \fIC4::Overdues::GetBranchcodesWithOverdueRules()\fR
.Sp
returns a list of branch codes for branches with overdue rules defined.
.RE
.SS "CheckAccountLineLevelInfo"
.IX Subsection "CheckAccountLineLevelInfo"
($exist) = &CheckAccountLineLevelInfo($borrowernumber,$itemnumber,$accounttype,notify_level);
.PP
Check and Returns the list of all overdue books.
.PP
\&\f(CW$exist\fR contains number of line in accounlines
with the same .biblionumber,itemnumber,accounttype,and notify_level
.PP
\&\f(CW$borrowernumber\fR contains the borrower number
.PP
\&\f(CW$itemnumber\fR contains item number
.PP
\&\f(CW$accounttype\fR contains account type
.PP
\&\f(CW$notify_level\fR contains the accountline level
.SS "GetOverduerules"
.IX Subsection "GetOverduerules"
($overduerules) = &GetOverduerules($categorycode);
.PP
Returns the value of borrowers (debarred or not) with notify level
.PP
\&\f(CW$overduerules\fR return value of debbraed field in overduerules table
.PP
\&\f(CW$category\fR contains the borrower categorycode
.PP
\&\f(CW$notify_level\fR contains the notify level
.SS "CheckBorrowerDebarred"
.IX Subsection "CheckBorrowerDebarred"
($debarredstatus) = &CheckBorrowerDebarred($borrowernumber);
.PP
Check if the borrowers is already debarred
.PP
\&\f(CW$debarredstatus\fR return 0 for not debarred and return 1 for debarred
.PP
\&\f(CW$borrowernumber\fR contains the borrower number
.SS "UpdateBorrowerDebarred"
.IX Subsection "UpdateBorrowerDebarred"
($borrowerstatut) = &UpdateBorrowerDebarred($borrowernumber);
.PP
update status of borrowers in borrowers table (field debarred)
.PP
\&\f(CW$borrowernumber\fR borrower number
.SS "CheckExistantNotifyid"
.IX Subsection "CheckExistantNotifyid"
.Vb 1
\&  ($exist) = &CheckExistantNotifyid($borrowernumber,$itemnumber,$accounttype,$notify_id);
.Ve
.PP
Check and Returns the notify id if exist else return 0.
.PP
\&\f(CW$exist\fR contains a notify_id
.PP
\&\f(CW$borrowernumber\fR contains the borrower number
.PP
\&\f(CW$date_due\fR contains the date of item return
.SS "CheckAccountLineItemInfo"
.IX Subsection "CheckAccountLineItemInfo"
.Vb 1
\&  ($exist) = &CheckAccountLineItemInfo($borrowernumber,$itemnumber,$accounttype,$notify_id);
.Ve
.PP
Check and Returns the list of all overdue items from the same file number(notify_id).
.PP
\&\f(CW$exist\fR contains number of line in accounlines
with the same .biblionumber,itemnumber,accounttype,notify_id
.PP
\&\f(CW$borrowernumber\fR contains the borrower number
.PP
\&\f(CW$itemnumber\fR contains item number
.PP
\&\f(CW$accounttype\fR contains account type
.PP
\&\f(CW$notify_id\fR contains the file number
.SS "CheckItemNotify"
.IX Subsection "CheckItemNotify"
Sql request to check if the document has alreday been notified
this function is not exported, only used with GetOverduesForBranch
.SS "GetOverduesForBranch"
.IX Subsection "GetOverduesForBranch"
Sql request for display all information for branchoverdues.pl
2 possibilities : with or without location .
display is filtered by branch
.PP
\&\s-1FIXME:\s0 This function should be renamed.
.SS "AddNotifyLine"
.IX Subsection "AddNotifyLine"
&AddNotifyLine($borrowernumber, \f(CW$itemnumber\fR, \f(CW$overduelevel\fR, \f(CW$method\fR, \f(CW$notifyId\fR)
.PP
Creat a line into notify, if the method is phone, the notification_send_date is implemented to
.SS "RemoveNotifyLine"
.IX Subsection "RemoveNotifyLine"
&RemoveNotifyLine( \f(CW$borrowernumber\fR, \f(CW$itemnumber\fR, \f(CW$notify_date\fR );
.PP
Cancel a notification
.SH "AUTHOR"
.IX Header "AUTHOR"
Koha Developement team <info@koha.org>
