.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "C4::Items 3"
.TH C4::Items 3 "2010-12-10" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Items \- item management functions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module contains an \s-1API\s0 for manipulating item 
records in Koha, and is used by cataloguing, circulation,
acquisitions, and serials management.
.PP
A Koha item record is stored in two places: the
items table and embedded in a \s-1MARC\s0 tag in the \s-1XML\s0
version of the associated bib record in \f(CW\*(C`biblioitems.marcxml\*(C'\fR.
This is done to allow the item information to be readily
indexed (e.g., by Zebra), but means that each item
modification transaction must keep the items table
and the \s-1MARC\s0 \s-1XML\s0 in sync at all times.
.PP
Consequently, all code that creates, modifies, or deletes
item records \fBmust\fR use an appropriate function from 
\&\f(CW\*(C`C4::Items\*(C'\fR.  If no existing function is suitable, it is
better to add one to \f(CW\*(C`C4::Items\*(C'\fR than to use add
one-off \s-1SQL\s0 statements to add or modify items.
.PP
The items table will be considered authoritative.  In other
words, if there is ever a discrepancy between the items
table and the \s-1MARC\s0 \s-1XML\s0, the items table should be considered
accurate.
.SH "HISTORICAL NOTE"
.IX Header "HISTORICAL NOTE"
Most of the functions in \f(CW\*(C`C4::Items\*(C'\fR were originally in
the \f(CW\*(C`C4::Biblio\*(C'\fR module.
.SH "CORE EXPORTED FUNCTIONS"
.IX Header "CORE EXPORTED FUNCTIONS"
The following functions are meant for use by users
of \f(CW\*(C`C4::Items\*(C'\fR
.SS "GetItem"
.IX Subsection "GetItem"
.RS 4
\&\f(CW$item\fR = GetItem($itemnumber,$barcode,$serial);
.RE
.PP
Return item information, for a given itemnumber or barcode.
The return value is a hashref mapping item column
names to values.  If \f(CW$serial\fR is true, include serial publication data.
.SS "AddItemFromMarc"
.IX Subsection "AddItemFromMarc"
.RS 4
my ($biblionumber, \f(CW$biblioitemnumber\fR, \f(CW$itemnumber\fR) 
    = AddItemFromMarc($source_item_marc, \f(CW$biblionumber\fR);
.RE
.PP
Given a MARC::Record object containing an embedded item
record and a biblionumber, create a new item record.
.SS "AddItem"
.IX Subsection "AddItem"
.RS 4
my ($biblionumber, \f(CW$biblioitemnumber\fR, \f(CW$itemnumber\fR) 
    = AddItem($item, \f(CW$biblionumber\fR[, \f(CW$dbh\fR, \f(CW$frameworkcode\fR, \f(CW$unlinked_item_subfields\fR]);
.RE
.PP
Given a hash containing item column names as keys,
create a new Koha item record.
.PP
The first two optional parameters (\f(CW$dbh\fR and \f(CW$frameworkcode\fR)
do not need to be supplied for general use; they exist
simply to allow them to be picked up from AddItemFromMarc.
.PP
The final optional parameter, \f(CW$unlinked_item_subfields\fR, contains
an arrayref containing subfields present in the original \s-1MARC\s0
representation of the item (e.g., from the item editor) that are
not mapped to \f(CW\*(C`items\*(C'\fR columns directly but should instead
be stored in \f(CW\*(C`items.more_subfields_xml\*(C'\fR and included in 
the biblio items tag for display and indexing.
.SS "AddItemBatchFromMarc"
.IX Subsection "AddItemBatchFromMarc"
.RS 4
($itemnumber_ref, \f(CW$error_ref\fR) = AddItemBatchFromMarc($record, \f(CW$biblionumber\fR, \f(CW$biblioitemnumber\fR, \f(CW$frameworkcode\fR);
.RE
.PP
Efficiently create item records from a \s-1MARC\s0 biblio record with
embedded item fields.  This routine is suitable for batch jobs.
.PP
This \s-1API\s0 assumes that the bib record has already been
saved to the \f(CW\*(C`biblio\*(C'\fR and \f(CW\*(C`biblioitems\*(C'\fR tables.  It does
not expect that \f(CW\*(C`biblioitems.marc\*(C'\fR and \f(CW\*(C`biblioitems.marcxml\*(C'\fR
are populated, but it will do so via a call to ModBibiloMarc.
.PP
The goal of this \s-1API\s0 is to have a similar effect to using AddBiblio
and AddItems in succession, but without inefficient repeated
parsing of the \s-1MARC\s0 \s-1XML\s0 bib record.
.PP
This function returns an arrayref of new itemsnumbers and an arrayref of item
errors encountered during the processing.  Each entry in the errors
list is a hashref containing the following keys:
.IP "item_sequence" 2
.IX Item "item_sequence"
Sequence number of original item tag in the \s-1MARC\s0 record.
.IP "item_barcode" 2
.IX Item "item_barcode"
Item barcode, provide to assist in the construction of
useful error messages.
.IP "error_condition" 2
.IX Item "error_condition"
Code representing the error condition.  Can be 'duplicate_barcode',
\&'invalid_homebranch', or 'invalid_holdingbranch'.
.IP "error_information" 2
.IX Item "error_information"
Additional information appropriate to the error condition.
.SS "ModItemFromMarc"
.IX Subsection "ModItemFromMarc"
.RS 4
ModItemFromMarc($item_marc, \f(CW$biblionumber\fR, \f(CW$itemnumber\fR);
.RE
.PP
This function updates an item record based on a supplied
\&\f(CW\*(C`MARC::Record\*(C'\fR object containing an embedded item field.
This \s-1API\s0 is meant for the use of \f(CW\*(C`additem.pl\*(C'\fR; for 
other purposes, \f(CW\*(C`ModItem\*(C'\fR should be used.
.PP
This function uses the hash \f(CW%default_values_for_mod_from_marc\fR,
which contains default values for item fields to
apply when modifying an item.  This is needed beccause
if an item field's value is cleared, TransformMarcToKoha
does not include the column in the
hash that's passed to ModItem, which without
use of this hash makes it impossible to clear
an item field's value.  See bug 2466.
.PP
Note that only columns that can be directly
changed from the cataloging and serials
item editors are included in this hash.
.SS "ModItem"
.IX Subsection "ModItem"
.RS 4
ModItem({ column => \f(CW$newvalue\fR }, \f(CW$biblionumber\fR, \f(CW$itemnumber\fR[, \f(CW$original_item_marc\fR]);
.RE
.PP
Change one or more columns in an item record and update
the \s-1MARC\s0 representation of the item.
.PP
The first argument is a hashref mapping from item column
names to the new values.  The second and third arguments
are the biblionumber and itemnumber, respectively.
.PP
The fourth, optional parameter, \f(CW$unlinked_item_subfields\fR, contains
an arrayref containing subfields present in the original \s-1MARC\s0
representation of the item (e.g., from the item editor) that are
not mapped to \f(CW\*(C`items\*(C'\fR columns directly but should instead
be stored in \f(CW\*(C`items.more_subfields_xml\*(C'\fR and included in 
the biblio items tag for display and indexing.
.PP
If one of the changed columns is used to calculate
the derived value of a column such as \f(CW\*(C`items.cn_sort\*(C'\fR, 
this routine will perform the necessary calculation
and set the value.
.SS "ModItemTransfer"
.IX Subsection "ModItemTransfer"
.RS 4
ModItemTransfer($itenumber, \f(CW$frombranch\fR, \f(CW$tobranch\fR);
.RE
.PP
Marks an item as being transferred from one branch
to another.
.SS "ModDateLastSeen"
.IX Subsection "ModDateLastSeen"
.RS 4
ModDateLastSeen($itemnum);
.RE
.PP
Mark item as seen. Is called when an item is issued, returned or manually marked during inventory/stocktaking.
\&\f(CW$itemnum\fR is the item number
.SS "DelItem"
.IX Subsection "DelItem"
.RS 4
DelItem($biblionumber, \f(CW$itemnumber\fR);
.RE
.PP
Exported function (core \s-1API\s0) for deleting an item record in Koha.
.SS "DelItemCheck"
.IX Subsection "DelItemCheck"
.RS 4
DelItemCheck($dbh, \f(CW$biblionumber\fR, \f(CW$itemnumber\fR);
.RE
.PP
Exported function (core \s-1API\s0) for deleting an item record in Koha if there no current issue.
.SS "CheckItemPreSave"
.IX Subsection "CheckItemPreSave"
.Vb 12
\&    my $item_ref = TransformMarcToKoha($marc, \*(Aqitems\*(Aq);
\&    # do stuff
\&    my %errors = CheckItemPreSave($item_ref);
\&    if (exists $errors{\*(Aqduplicate_barcode\*(Aq}) {
\&        print "item has duplicate barcode: ", $errors{\*(Aqduplicate_barcode\*(Aq}, "\en";
\&    } elsif (exists $errors{\*(Aqinvalid_homebranch\*(Aq}) {
\&        print "item has invalid home branch: ", $errors{\*(Aqinvalid_homebranch\*(Aq}, "\en";
\&    } elsif (exists $errors{\*(Aqinvalid_holdingbranch\*(Aq}) {
\&        print "item has invalid holding branch: ", $errors{\*(Aqinvalid_holdingbranch\*(Aq}, "\en";
\&    } else {
\&        print "item is OK";
\&    }
.Ve
.PP
Given a hashref containing item fields, determine if it can be
inserted or updated in the database.  Specifically, checks for
database integrity issues, and returns a hash containing any
of the following keys, if applicable.
.IP "duplicate_barcode" 2
.IX Item "duplicate_barcode"
Barcode, if it duplicates one already found in the database.
.IP "invalid_homebranch" 2
.IX Item "invalid_homebranch"
Home branch, if not defined in branches table.
.IP "invalid_holdingbranch" 2
.IX Item "invalid_holdingbranch"
Holding branch, if not defined in branches table.
.PP
This function does \s-1NOT\s0 implement any policy-related checks,
e.g., whether current operator is allowed to save an
item that has a given branch code.
.SH "EXPORTED SPECIAL ACCESSOR FUNCTIONS"
.IX Header "EXPORTED SPECIAL ACCESSOR FUNCTIONS"
The following functions provide various ways of 
getting an item record, a set of item records, or
lists of authorized values for certain item fields.
.PP
Some of the functions in this group are candidates
for refactoring \*(-- for example, some of the code
in \f(CW\*(C`GetItemsByBiblioitemnumber\*(C'\fR and \f(CW\*(C`GetItemsInfo\*(C'\fR
has copy-and-paste work.
.SS "GetItemStatus"
.IX Subsection "GetItemStatus"
.RS 4
\&\f(CW$itemstatushash\fR = GetItemStatus($fwkcode);
.RE
.PP
Returns a list of valid values for the
\&\f(CW\*(C`items.notforloan\*(C'\fR field.
.PP
\&\s-1NOTE:\s0 does \fBnot\fR return an individual item's
status.
.PP
Can be \s-1MARC\s0 dependant.
fwkcode is optional.
But basically could be can be loan or not
Create a status selector with the following code
.PP
\fIin \s-1PERL\s0 \s-1SCRIPT\s0\fR
.IX Subsection "in PERL SCRIPT"
.Sp
.RS 4
my \f(CW$itemstatushash\fR = getitemstatus;
my \f(CW@itemstatusloop\fR;
foreach my \f(CW$thisstatus\fR (keys %$itemstatushash) {
    my \f(CW%row\fR =(value => \f(CW$thisstatus\fR,
                statusname => \f(CW$itemstatushash\fR\->{$thisstatus}\->{'statusname'},
            );
    push \f(CW@itemstatusloop\fR, \e%row;
}
\&\f(CW$template\fR\->param(statusloop=>\e@itemstatusloop);
.RE
.PP
\fIin \s-1TEMPLATE\s0\fR
.IX Subsection "in TEMPLATE"
.Sp
.RS 4
<select name=\*(L"statusloop\*(R">
    <option value="\*(L">Default</option>
<!\-\- \s-1TMPL_LOOP\s0 name=\*(R"statusloop\*(L" \-\->
    <option value=\*(R"<!\-\- \s-1TMPL_VAR\s0 name=\*(L"value\*(R" \-\->\*(L" <!\-\- \s-1TMPL_IF\s0 name=\*(R"selected\*(L" \-\->selected<!\-\- /TMPL_IF \-\->><!\-\- \s-1TMPL_VAR\s0 name=\*(R"statusname" \-\-></option>
<!\-\- /TMPL_LOOP \-\->
</select>
.RE
.SS "GetItemLocation"
.IX Subsection "GetItemLocation"
.RS 4
\&\f(CW$itemlochash\fR = GetItemLocation($fwk);
.RE
.PP
Returns a list of valid values for the
\&\f(CW\*(C`items.location\*(C'\fR field.
.PP
\&\s-1NOTE:\s0 does \fBnot\fR return an individual item's
location.
.PP
where fwk stands for an optional framework code.
Create a location selector with the following code
.PP
\fIin \s-1PERL\s0 \s-1SCRIPT\s0\fR
.IX Subsection "in PERL SCRIPT"
.Sp
.RS 4
my \f(CW$itemlochash\fR = getitemlocation;
my \f(CW@itemlocloop\fR;
foreach my \f(CW$thisloc\fR (keys %$itemlochash) {
    my \f(CW$selected\fR = 1 if \f(CW$thisbranch\fR eq \f(CW$branch\fR;
    my \f(CW%row\fR =(locval => \f(CW$thisloc\fR,
                selected => \f(CW$selected\fR,
                locname => \f(CW$itemlochash\fR\->{$thisloc},
            );
    push \f(CW@itemlocloop\fR, \e%row;
}
\&\f(CW$template\fR\->param(itemlocationloop => \e@itemlocloop);
.RE
.PP
\fIin \s-1TEMPLATE\s0\fR
.IX Subsection "in TEMPLATE"
.Sp
.RS 4
<select name=\*(L"location\*(R">
    <option value="\*(L">Default</option>
<!\-\- \s-1TMPL_LOOP\s0 name=\*(R"itemlocationloop\*(L" \-\->
    <option value=\*(R"<!\-\- \s-1TMPL_VAR\s0 name=\*(L"locval\*(R" \-\->\*(L" <!\-\- \s-1TMPL_IF\s0 name=\*(R"selected\*(L" \-\->selected<!\-\- /TMPL_IF \-\->><!\-\- \s-1TMPL_VAR\s0 name=\*(R"locname" \-\-></option>
<!\-\- /TMPL_LOOP \-\->
</select>
.RE
.SS "GetLostItems"
.IX Subsection "GetLostItems"
.RS 4
\&\f(CW$items\fR = GetLostItems( \f(CW$where\fR, \f(CW$orderby\fR );
.RE
.PP
This function gets a list of lost items.
.IP "input:" 2
.IX Item "input:"
\&\f(CW$where\fR is a hashref. it containts a field of the items table as key
and the value to match as value. For example:
.Sp
{ barcode    => 'abc123',
  homebranch => '\s-1CPL\s0',    }
.Sp
\&\f(CW$orderby\fR is a field of the items table by which the resultset
should be orderd.
.IP "return:" 2
.IX Item "return:"
\&\f(CW$items\fR is a reference to an array full of hashrefs with columns
from the \*(L"items\*(R" table as keys.
.IP "usage in the perl script:" 2
.IX Item "usage in the perl script:"
my \f(CW$where\fR = { barcode => '0001548' };
my \f(CW$items\fR = GetLostItems( \f(CW$where\fR, \*(L"homebranch\*(R" );
\&\f(CW$template\fR\->param( itemsloop => \f(CW$items\fR );
.SS "GetItemsForInventory"
.IX Subsection "GetItemsForInventory"
.RS 4
\&\f(CW$itemlist\fR = GetItemsForInventory($minlocation, \f(CW$maxlocation\fR, \f(CW$location\fR, \f(CW$itemtype\fR \f(CW$datelastseen\fR, \f(CW$branch\fR, \f(CW$offset\fR, \f(CW$size\fR);
.RE
.PP
Retrieve a list of title/authors/barcode/callnumber, for biblio inventory.
.PP
The sub returns a reference to a list of hashes, each containing
itemnumber, author, title, barcode, item callnumber, and date last
seen. It is ordered by callnumber then title.
.PP
The required minlocation & maxlocation parameters are used to specify a range of item callnumbers
the datelastseen can be used to specify that you want to see items not seen since a past date only.
offset & size can be used to retrieve only a part of the whole listing (defaut behaviour)
.SS "GetItemsCount"
.IX Subsection "GetItemsCount"
This function return count of item with \f(CW$biblionumber\fR
.SS "GetItemInfosOf"
.IX Subsection "GetItemInfosOf"
.RS 4
GetItemInfosOf(@itemnumbers);
.RE
.SS "GetItemsByBiblioitemnumber"
.IX Subsection "GetItemsByBiblioitemnumber"
.RS 4
GetItemsByBiblioitemnumber($biblioitemnumber);
.RE
.PP
Returns an arrayref of hashrefs suitable for use in a \s-1TMPL_LOOP\s0
Called by \f(CW\*(C`C4::XISBN\*(C'\fR
.SS "GetItemsInfo"
.IX Subsection "GetItemsInfo"
.RS 4
\&\f(CW@results\fR = GetItemsInfo($biblionumber, \f(CW$type\fR);
.RE
.PP
Returns information about books with the given biblionumber.
.PP
\&\f(CW$type\fR may be either \f(CW\*(C`intra\*(C'\fR or anything else. If it is not set to
\&\f(CW\*(C`intra\*(C'\fR, then the search will exclude lost, very overdue, and
withdrawn items.
.PP
\&\f(CW\*(C`GetItemsInfo\*(C'\fR returns a list of references-to-hash. Each element
contains a number of keys. Most of them are table items from the
\&\f(CW\*(C`biblio\*(C'\fR, \f(CW\*(C`biblioitems\*(C'\fR, \f(CW\*(C`items\*(C'\fR, and \f(CW\*(C`itemtypes\*(C'\fR tables in the
Koha database. Other keys include:
.ie n .IP """$data\->{branchname}""" 2
.el .IP "\f(CW$data\->{branchname}\fR" 2
.IX Item "$data->{branchname}"
The name (not the code) of the branch to which the book belongs.
.ie n .IP """$data\->{datelastseen}""" 2
.el .IP "\f(CW$data\->{datelastseen}\fR" 2
.IX Item "$data->{datelastseen}"
This is simply \f(CW\*(C`items.datelastseen\*(C'\fR, except that while the date is
stored in YYYY-MM-DD format in the database, here it is converted to
\&\s-1DD/MM/YYYY\s0 format. A \s-1NULL\s0 date is returned as \f(CW\*(C`//\*(C'\fR.
.ie n .IP """$data\->{datedue}""" 2
.el .IP "\f(CW$data\->{datedue}\fR" 2
.IX Item "$data->{datedue}"
.PD 0
.ie n .IP """$data\->{class}""" 2
.el .IP "\f(CW$data\->{class}\fR" 2
.IX Item "$data->{class}"
.PD
This is the concatenation of \f(CW\*(C`biblioitems.classification\*(C'\fR, the book's
Dewey code, and \f(CW\*(C`biblioitems.subclass\*(C'\fR.
.ie n .IP """$data\->{ocount}""" 2
.el .IP "\f(CW$data\->{ocount}\fR" 2
.IX Item "$data->{ocount}"
I think this is the number of copies of the book available.
.ie n .IP """$data\->{order}""" 2
.el .IP "\f(CW$data\->{order}\fR" 2
.IX Item "$data->{order}"
If this is set, it is set to \f(CW\*(C`One Order\*(C'\fR.
.SS "get_itemnumbers_of"
.IX Subsection "get_itemnumbers_of"
.RS 4
my \f(CW@itemnumbers_of\fR = get_itemnumbers_of(@biblionumbers);
.RE
.PP
Given a list of biblionumbers, return the list of corresponding itemnumbers
for each biblionumber.
.PP
Return a reference on a hash where keys are biblionumbers and values are
references on array of itemnumbers.
.SS "GetItemnumberFromBarcode"
.IX Subsection "GetItemnumberFromBarcode"
.RS 4
\&\f(CW$result\fR = GetItemnumberFromBarcode($barcode);
.RE
.PP
\fIget_item_authorised_values\fR
.IX Subsection "get_item_authorised_values"
.PP
.Vb 1
\&  find the types and values for all authorised values assigned to this item.
\&
\&  parameters:
\&    itemnumber
\&
\&  returns: a hashref malling the authorised value to the value set for this itemnumber
\&
\&    $authorised_values = {
\&             \*(AqCCODE\*(Aq      => undef,
\&             \*(AqDAMAGED\*(Aq    => \*(Aq0\*(Aq,
\&             \*(AqLOC\*(Aq        => \*(Aq3\*(Aq,
\&             \*(AqLOST\*(Aq       => \*(Aq0\*(Aq
\&             \*(AqNOT_LOAN\*(Aq   => \*(Aq0\*(Aq,
\&             \*(AqRESTRICTED\*(Aq => undef,
\&             \*(AqSTACK\*(Aq      => undef,
\&             \*(AqWITHDRAWN\*(Aq  => \*(Aq0\*(Aq,
\&             \*(Aqbranches\*(Aq   => \*(AqCPL\*(Aq,
\&             \*(Aqcn_source\*(Aq  => undef,
\&             \*(Aqitemtypes\*(Aq  => \*(AqSER\*(Aq,
\&           };
\&
\&   Notes: see C4::Biblio::get_biblio_authorised_values for a similar method at the biblio level.
.Ve
.PP
\fIget_authorised_value_images\fR
.IX Subsection "get_authorised_value_images"
.PP
.Vb 2
\&  find a list of icons that are appropriate for display based on the
\&  authorised values for a biblio.
\&
\&  parameters: listref of authorised values, such as comes from
\&    get_item_authorised_values or
\&    from C4::Biblio::get_biblio_authorised_values
\&
\&  returns: listref of hashrefs for each image. Each hashref looks like
\&    this:
\&
\&      { imageurl => \*(Aq/intranet\-tmpl/prog/img/itemtypeimg/npl/WEB.gif\*(Aq,
\&        label    => \*(Aq\*(Aq,
\&        category => \*(Aq\*(Aq,
\&        value    => \*(Aq\*(Aq, }
\&
\&  Notes: Currently, I put on the full path to the images on the staff
\&  side. This should either be configurable or not done at all. Since I
\&  have to deal with \*(Aqintranet\*(Aq or \*(Aqopac\*(Aq in
\&  get_biblio_authorised_values, perhaps I should be passing it in.
.Ve
.SH "LIMITED USE FUNCTIONS"
.IX Header "LIMITED USE FUNCTIONS"
The following functions, while part of the public \s-1API\s0,
are not exported.  This is generally because they are
meant to be used by only one script for a specific
purpose, and should not be used in any other context
without careful thought.
.SS "GetMarcItem"
.IX Subsection "GetMarcItem"
.RS 4
my \f(CW$item_marc\fR = GetMarcItem($biblionumber, \f(CW$itemnumber\fR);
.RE
.PP
Returns MARC::Record of the item passed in parameter.
This function is meant for use only in \f(CW\*(C`cataloguing/additem.pl\*(C'\fR,
where it is needed to support that script's MARC-like
editor.
.SH "PRIVATE FUNCTIONS AND VARIABLES"
.IX Header "PRIVATE FUNCTIONS AND VARIABLES"
The following functions are not meant to be called
directly, but are documented in order to explain
the inner workings of \f(CW\*(C`C4::Items\*(C'\fR.
.ie n .SS "%derived_columns"
.el .SS "\f(CW%derived_columns\fP"
.IX Subsection "%derived_columns"
This hash keeps track of item columns that
are strictly derived from other columns in
the item record and are not meant to be set
independently.
.PP
Each key in the hash should be the name of a
column (as named by TransformMarcToKoha).  Each
value should be hashref whose keys are the
columns on which the derived column depends.  The
hashref should also contain a '\s-1BUILDER\s0' key
that is a reference to a sub that calculates
the derived value.
.SS "_set_derived_columns_for_add"
.IX Subsection "_set_derived_columns_for_add"
.RS 4
_set_derived_column_for_add($item);
.RE
.PP
Given an item hash representing a new item to be added,
calculate any derived columns.  Currently the only
such column is \f(CW\*(C`items.cn_sort\*(C'\fR.
.SS "_set_derived_columns_for_mod"
.IX Subsection "_set_derived_columns_for_mod"
.RS 4
_set_derived_column_for_mod($item);
.RE
.PP
Given an item hash representing a new item to be modified.
calculate any derived columns.  Currently the only
such column is \f(CW\*(C`items.cn_sort\*(C'\fR.
.PP
This routine differs from \f(CW\*(C`_set_derived_columns_for_add\*(C'\fR
in that it needs to handle partial item records.  In other
words, the caller of \f(CW\*(C`ModItem\*(C'\fR may have supplied only one
or two columns to be changed, so this function needs to
determine whether any of the columns to be changed affect
any of the derived columns.  Also, if a derived column
depends on more than one column, but the caller is not
changing all of then, this routine retrieves the unchanged
values from the database in order to ensure a correct
calculation.
.SS "_do_column_fixes_for_mod"
.IX Subsection "_do_column_fixes_for_mod"
.RS 4
_do_column_fixes_for_mod($item);
.RE
.PP
Given an item hashref containing one or more
columns to modify, fix up certain values.
Specifically, set to 0 any passed value
of \f(CW\*(C`notforloan\*(C'\fR, \f(CW\*(C`damaged\*(C'\fR, \f(CW\*(C`itemlost\*(C'\fR, or
\&\f(CW\*(C`wthdrawn\*(C'\fR that is either undefined or
contains the empty string.
.SS "_get_single_item_column"
.IX Subsection "_get_single_item_column"
.RS 4
_get_single_item_column($column, \f(CW$itemnumber\fR);
.RE
.PP
Retrieves the value of a single column from an \f(CW\*(C`items\*(C'\fR
row specified by \f(CW$itemnumber\fR.
.SS "_calc_items_cn_sort"
.IX Subsection "_calc_items_cn_sort"
.RS 4
_calc_items_cn_sort($item, \f(CW$source_values\fR);
.RE
.PP
Helper routine to calculate \f(CW\*(C`items.cn_sort\*(C'\fR.
.SS "_set_defaults_for_add"
.IX Subsection "_set_defaults_for_add"
.RS 4
_set_defaults_for_add($item_hash);
.RE
.PP
Given an item hash representing an item to be added, set
correct default values for columns whose default value
is not handled by the \s-1DBMS\s0.  This includes the following
columns:
.IP "\(bu" 2
\&\f(CW\*(C`items.dateaccessioned\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`items.notforloan\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`items.damaged\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`items.itemlost\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`items.wthdrawn\*(C'\fR
.SS "_koha_new_item"
.IX Subsection "_koha_new_item"
.RS 4
my ($itemnumber,$error) = _koha_new_item( \f(CW$item\fR, \f(CW$barcode\fR );
.RE
.PP
Perform the actual insert into the \f(CW\*(C`items\*(C'\fR table.
.SS "_koha_modify_item"
.IX Subsection "_koha_modify_item"
.RS 4
my ($itemnumber,$error) =_koha_modify_item( \f(CW$item\fR );
.RE
.PP
Perform the actual update of the \f(CW\*(C`items\*(C'\fR row.  Note that this
routine accepts a hashref specifying the columns to update.
.SS "_koha_delete_item"
.IX Subsection "_koha_delete_item"
.RS 4
_koha_delete_item( \f(CW$dbh\fR, \f(CW$itemnum\fR );
.RE
.PP
Internal function to delete an item record from the koha tables
.SS "_marc_from_item_hash"
.IX Subsection "_marc_from_item_hash"
.RS 4
my \f(CW$item_marc\fR = _marc_from_item_hash($item, \f(CW$frameworkcode\fR[, \f(CW$unlinked_item_subfields\fR]);
.RE
.PP
Given an item hash representing a complete item record,
create a \f(CW\*(C`MARC::Record\*(C'\fR object containing an embedded
tag representing that item.
.PP
The third, optional parameter \f(CW$unlinked_item_subfields\fR is
an arrayref of subfields (not mapped to \f(CW\*(C`items\*(C'\fR fields per the
framework) to be added to the \s-1MARC\s0 representation
of the item.
.SS "_add_item_field_to_biblio"
.IX Subsection "_add_item_field_to_biblio"
.RS 4
_add_item_field_to_biblio($item_marc, \f(CW$biblionumber\fR, \f(CW$frameworkcode\fR);
.RE
.PP
Adds the fields from a \s-1MARC\s0 record containing the
representation of a Koha item record to the \s-1MARC\s0
biblio record.  The input \f(CW$item_marc\fR record
is expect to contain just one field, the embedded
item information field.
.SS "_replace_item_field_in_biblio"
.IX Subsection "_replace_item_field_in_biblio"
.RS 4
&_replace_item_field_in_biblio($item_marc, \f(CW$biblionumber\fR, \f(CW$itemnumber\fR, \f(CW$frameworkcode\fR)
.RE
.PP
Given a MARC::Record \f(CW$item_marc\fR containing one tag with the \s-1MARC\s0 
representation of the item, examine the biblio \s-1MARC\s0
for the corresponding tag for that item and 
replace it with the tag from \f(CW$item_marc\fR.
.SS "_repack_item_errors"
.IX Subsection "_repack_item_errors"
Add an error message hash generated by \f(CW\*(C`CheckItemPreSave\*(C'\fR
to a list of errors.
.SS "_get_unlinked_item_subfields"
.IX Subsection "_get_unlinked_item_subfields"
.RS 4
my \f(CW$unlinked_item_subfields\fR = _get_unlinked_item_subfields($original_item_marc, \f(CW$frameworkcode\fR);
.RE
.SS "_get_unlinked_subfields_xml"
.IX Subsection "_get_unlinked_subfields_xml"
.RS 4
my \f(CW$unlinked_subfields_xml\fR = _get_unlinked_subfields_xml($unlinked_item_subfields);
.RE
.SS "_parse_unlinked_item_subfields_from_xml"
.IX Subsection "_parse_unlinked_item_subfields_from_xml"
.RS 4
my \f(CW$unlinked_item_subfields\fR = _parse_unlinked_item_subfields_from_xml($whole_item\->{'more_subfields_xml'}):
.RE
