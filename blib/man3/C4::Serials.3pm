.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "C4::Serials 3"
.TH C4::Serials 3 "2010-12-10" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SS "GetSuppliersWithLateIssues"
.IX Subsection "GetSuppliersWithLateIssues"
.SH "NAME"
C4::Serials \- Give functions for serializing.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use C4::Serials;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Give all \s-1XYZ\s0 functions
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.RS 4
\&\f(CW%supplierlist\fR = &GetSuppliersWithLateIssues
.Sp
this function get all suppliers with late issues.
.Sp
return :
the supplierlist into a hash. this hash containts id & name of the supplier
.RE
.SS "GetLateIssues"
.IX Subsection "GetLateIssues"
.RS 4
\&\f(CW@issuelist\fR = &GetLateIssues($supplierid)
.Sp
this function select late issues on database
.Sp
return :
the issuelist into an table. Each line of this table containts a ref to a hash which it containts
name,title,planneddate,serialseq,serial.subscriptionid from tables : subscription, serial & biblio
.RE
.SS "GetSubscriptionHistoryFromSubscriptionId"
.IX Subsection "GetSubscriptionHistoryFromSubscriptionId"
.RS 4
\&\f(CW$sth\fR = \fIGetSubscriptionHistoryFromSubscriptionId()\fR
this function just prepare the \s-1SQL\s0 request.
After this function, don't forget to execute it by using \f(CW$sth\fR\->execute($subscriptionid)
return :
\&\f(CW$sth\fR = \f(CW$dbh\fR\->prepare($query).
.RE
.SS "GetSerialStatusFromSerialId"
.IX Subsection "GetSerialStatusFromSerialId"
.RS 4
\&\f(CW$sth\fR = \fIGetSerialStatusFromSerialId()\fR;
this function just prepare the \s-1SQL\s0 request.
After this function, don't forget to execute it by using \f(CW$sth\fR\->execute($serialid)
return :
\&\f(CW$sth\fR = \f(CW$dbh\fR\->prepare($query).
.RE
.SS "GetSerialInformation"
.IX Subsection "GetSerialInformation"
.RS 4
\&\f(CW$data\fR = GetSerialInformation($serialid);
returns a hash containing :
  items : items marcrecord (can be an array)
  serial table field
  subscription table field
  + information about subscription expiration
.RE
.SS "AddItem2Serial"
.IX Subsection "AddItem2Serial"
.RS 4
\&\f(CW$data\fR = AddItem2Serial($serialid,$itemnumber);
Adds an itemnumber to Serial record
.RE
.SS "UpdateClaimdateIssues"
.IX Subsection "UpdateClaimdateIssues"
.RS 4
UpdateClaimdateIssues($serialids,[$date]);
.Sp
Update Claimdate for issues in @$serialids list with date \f(CW$date\fR 
(Take Today if none)
.RE
.SS "GetSubscription"
.IX Subsection "GetSubscription"
.RS 4
\&\f(CW$subs\fR = GetSubscription($subscriptionid)
this function get the subscription which has \f(CW$subscriptionid\fR as id.
return :
a hashref. This hash containts
subscription, subscriptionhistory, aqbudget.bookfundid, biblio.title
.RE
.SS "GetFullSubscription"
.IX Subsection "GetFullSubscription"
.Vb 2
\&   \e@res = GetFullSubscription($subscriptionid)
\&   this function read on serial table.
.Ve
.SS "PrepareSerialsData"
.IX Subsection "PrepareSerialsData"
.Vb 2
\&   \e@res = PrepareSerialsData($serialinfomation)
\&   where serialinformation is a hashref array
.Ve
.SS "GetSubscriptionsFromBiblionumber"
.IX Subsection "GetSubscriptionsFromBiblionumber"
\&\e@res = GetSubscriptionsFromBiblionumber($biblionumber)
this function get the subscription list. it reads on subscription table.
return :
table of subscription which has the biblionumber given on input arg.
each line of this table is a hashref. All hashes containt
startdate, histstartdate,opacnote,missinglist,recievedlist,periodicity,status & enddate
.SS "GetFullSubscriptionsFromBiblionumber"
.IX Subsection "GetFullSubscriptionsFromBiblionumber"
.Vb 2
\&   \e@res = GetFullSubscriptionsFromBiblionumber($biblionumber)
\&   this function read on serial table.
.Ve
.SS "GetSubscriptions"
.IX Subsection "GetSubscriptions"
.RS 4
\&\f(CW@results\fR = GetSubscriptions($title,$ISSN,$biblionumber);
this function get all subscriptions which has title like \f(CW$title\fR,ISSN like \f(CW$ISSN\fR and biblionumber like \f(CW$biblionumber\fR.
return:
a table of hashref. Each hash containt the subscription.
.RE
.SS "GetSerials"
.IX Subsection "GetSerials"
.RS 4
($totalissues,@serials) = GetSerials($subscriptionid);
this function get every serial not arrived for a given subscription
as well as the number of issues registered in the database (all types)
this number is used to see if a subscription can be deleted (=it must have only 1 issue)
.Sp
\&\s-1FIXME:\s0 We should return \e@serials.
.RE
.SS "GetSerials2"
.IX Subsection "GetSerials2"
.RS 4
($totalissues,@serials) = GetSerials2($subscriptionid,$status);
this function get every serial waited for a given subscription
as well as the number of issues registered in the database (all types)
this number is used to see if a subscription can be deleted (=it must have only 1 issue)
.RE
.SS "GetLatestSerials"
.IX Subsection "GetLatestSerials"
.RS 4
\&\e@serials = GetLatestSerials($subscriptionid,$limit)
get the \f(CW$limit\fR's latest serials arrived or missing for a given subscription
return :
a ref to a table which it containts all of the latest serials stored into a hash.
.RE
.SS "GetNextSeq"
.IX Subsection "GetNextSeq"
.RS 4
GetNextSeq($val)
\&\f(CW$val\fR is a hashref containing all the attributes of the table 'subscription'
This function get the next issue for the subscription given on input arg
return:
all the input params updated.
.RE
.SS "GetSeq"
.IX Subsection "GetSeq"
.RS 4
\&\f(CW$calculated\fR = GetSeq($val)
\&\f(CW$val\fR is a hashref containing all the attributes of the table 'subscription'
this function transforms {X},{Y},{Z} to 150,0,0 for example.
return:
the sequence in integer format
.RE
.SS "GetExpirationDate"
.IX Subsection "GetExpirationDate"
\&\f(CW$sensddate\fR = GetExpirationDate($subscriptionid)
.PP
this function return the expiration date for a subscription given on input args.
.PP
return
the enddate
.SS "CountSubscriptionFromBiblionumber"
.IX Subsection "CountSubscriptionFromBiblionumber"
.RS 4
\&\f(CW$subscriptionsnumber\fR = CountSubscriptionFromBiblionumber($biblionumber)
this count the number of subscription for a biblionumber given.
return :
the number of subscriptions with biblionumber given on input arg.
.RE
.SS "ModSubscriptionHistory"
.IX Subsection "ModSubscriptionHistory"
.RS 4
ModSubscriptionHistory($subscriptionid,$histstartdate,$enddate,$recievedlist,$missinglist,$opacnote,$librariannote);
.Sp
this function modify the history of a subscription. Put your new values on input arg.
.RE
.SS "ModSerialStatus"
.IX Subsection "ModSerialStatus"
.RS 4
ModSerialStatus($serialid,$serialseq, \f(CW$planneddate\fR,$publisheddate,$status,$notes)
.Sp
This function modify the serial status. Serial status is a number.(eg 2 is \*(L"arrived\*(R")
Note : if we change from \*(L"waited\*(R" to something else,then we will have to create a new \*(L"waited\*(R" entry
.RE
.SS "GetNextExpected"
.IX Subsection "GetNextExpected"
.RS 4
\&\f(CW$nextexpected\fR = GetNextExpected($subscriptionid)
.Sp
Get the planneddate for the current expected issue of the subscription.
.Sp
returns a hashref:
.Sp
\&\f(CW$nextexepected\fR = {
    serialid => int
    planneddate => C4::Dates object
    }
.RE
.SS "ModNextExpected"
.IX Subsection "ModNextExpected"
.RS 4
ModNextExpected($subscriptionid,$date)
.Sp
Update the planneddate for the current expected issue of the subscription.
This will modify all future prediction results.
.Sp
\&\f(CW$date\fR is a C4::Dates object.
.RE
.SS "ModSubscription"
.IX Subsection "ModSubscription"
.RS 4
this function modify a subscription. Put all new values on input args.
.RE
.SS "NewSubscription"
.IX Subsection "NewSubscription"
.RS 4
\&\f(CW$subscriptionid\fR = &NewSubscription($auser,branchcode,$aqbooksellerid,$cost,$aqbudgetid,$biblionumber,
    \f(CW$startdate\fR,$periodicity,$dow,$numberlength,$weeklength,$monthlength,
    \f(CW$add1\fR,$every1,$whenmorethan1,$setto1,$lastvalue1,$innerloop1,
    \f(CW$add2\fR,$every2,$whenmorethan2,$setto2,$lastvalue2,$innerloop2,
    \f(CW$add3\fR,$every3,$whenmorethan3,$setto3,$lastvalue3,$innerloop3,
    \f(CW$numberingmethod\fR, \f(CW$status\fR, \f(CW$notes\fR, \f(CW$serialsadditems\fR)
.Sp
Create a new subscription with value given on input args.
.Sp
return :
the id of this new subscription
.RE
.SS "ReNewSubscription"
.IX Subsection "ReNewSubscription"
.RS 4
ReNewSubscription($subscriptionid,$user,$startdate,$numberlength,$weeklength,$monthlength,$note)
.Sp
this function renew a subscription with values given on input args.
.RE
.SS "NewIssue"
.IX Subsection "NewIssue"
.RS 4
NewIssue($serialseq,$subscriptionid,$biblionumber,$status, \f(CW$planneddate\fR, \f(CW$publisheddate\fR,  \f(CW$notes\fR)
.Sp
Create a new issue stored on the database.
Note : we have to update the recievedlist and missinglist on subscriptionhistory for this subscription.
.RE
.SS "ItemizeSerials"
.IX Subsection "ItemizeSerials"
.RS 4
ItemizeSerials($serialid, \f(CW$info\fR);
\&\f(CW$info\fR is a hashref containing  barcode branch, itemcallnumber, status, location
\&\f(CW$serialid\fR the serialid
return :
1 if the itemize is a succes.
0 and \f(CW@error\fR else. \f(CW@error\fR containts the list of errors found.
.RE
.SS "HasSubscriptionExpired"
.IX Subsection "HasSubscriptionExpired"
.RS 4
\&\f(CW$has_expired\fR = HasSubscriptionExpired($subscriptionid)
.Sp
the subscription has expired when the next issue to arrive is out of subscription limit.
.Sp
return :
0 if the subscription has not expired
1 if the subscription has expired
2 if has subscription does not have a valid expiration date set
.RE
.SS "DelSubscription"
.IX Subsection "DelSubscription"
.RS 4
DelSubscription($subscriptionid)
this function delete the subscription which has \f(CW$subscriptionid\fR as id.
.RE
.SS "DelIssue"
.IX Subsection "DelIssue"
.RS 4
DelIssue($serialseq,$subscriptionid)
this function delete an issue which has \f(CW$serialseq\fR and \f(CW$subscriptionid\fR given on input arg.
.RE
.SS "GetLateOrMissingIssues"
.IX Subsection "GetLateOrMissingIssues"
.RS 4
($count,@issuelist) = &GetLateMissingIssues($supplierid,$serialid)
.Sp
this function select missing issues on database \- where serial.status = 4 or serial.status=3 or planneddate<now
.Sp
return :
a count of the number of missing issues
the issuelist into a table. Each line of this table containts a ref to a hash which it containts
name,title,planneddate,serialseq,serial.subscriptionid from tables : subscription, serial & biblio
.RE
.SS "removeMissingIssue"
.IX Subsection "removeMissingIssue"
.RS 4
removeMissingIssue($subscriptionid)
.Sp
this function removes an issue from being part of the missing string in 
subscriptionlist.missinglist column
.Sp
called when a missing issue is found from the serials\-recieve.pl file
.RE
.SS "updateClaim"
.IX Subsection "updateClaim"
.RS 4
&updateClaim($serialid)
.Sp
this function updates the time when a claim is issued for late/missing items
.Sp
called from claims.pl file
.RE
.SS "getsupplierbyserialid"
.IX Subsection "getsupplierbyserialid"
.RS 4
($result) = &getsupplierbyserialid($serialid)
.Sp
this function is used to find the supplier id given a serial id
.Sp
return :
hashref containing serialid, subscriptionid, and aqbooksellerid
.RE
.SS "check_routing"
.IX Subsection "check_routing"
.RS 4
($result) = &check_routing($subscriptionid)
.Sp
this function checks to see if a serial has a routing list and returns the count of routingid
used to show either an 'add' or 'edit' link
.RE
.SS "addroutingmember"
.IX Subsection "addroutingmember"
.RS 4
&addroutingmember($borrowernumber,$subscriptionid)
.Sp
this function takes a borrowernumber and subscriptionid and add the member to the
routing list for that serial subscription and gives them a rank on the list
of either 1 or highest current rank + 1
.RE
.SS "reorder_members"
.IX Subsection "reorder_members"
.RS 4
&reorder_members($subscriptionid,$routingid,$rank)
.Sp
this function is used to reorder the routing list
.Sp
it takes the routingid of the member one wants to re-rank and the rank it is to move to
\&\- it gets all members on list puts their routingid's into an array
\&\- removes the one in the array that is \f(CW$routingid\fR
\&\- then reinjects \f(CW$routingid\fR at point indicated by \f(CW$rank\fR
\&\- then update the database with the routingids in the new order
.RE
.SS "delroutingmember"
.IX Subsection "delroutingmember"
.RS 4
&delroutingmember($routingid,$subscriptionid)
.Sp
this function either deletes one member from routing list if \f(CW$routingid\fR exists otherwise
deletes all members from the routing list
.RE
.SS "getroutinglist"
.IX Subsection "getroutinglist"
.RS 4
($count,@routinglist) = &getroutinglist($subscriptionid)
.Sp
this gets the info from the subscriptionroutinglist for \f(CW$subscriptionid\fR
.Sp
return :
a count of the number of members on routinglist
the routinglist into a table. Each line of this table containts a ref to a hash which containts
routingid \- a unique id, borrowernumber, ranking, and biblionumber of subscription
.RE
.SS "countissuesfrom"
.IX Subsection "countissuesfrom"
.RS 4
\&\f(CW$result\fR = &countissuesfrom($subscriptionid,$startdate)
.RE
.SS "abouttoexpire"
.IX Subsection "abouttoexpire"
.RS 4
\&\f(CW$result\fR = &abouttoexpire($subscriptionid)
.Sp
this function alerts you to the penultimate issue for a serial subscription
.Sp
returns 1 \- if this is the penultimate issue
returns 0 \- if not
.RE
.SS "GetNextDate"
.IX Subsection "GetNextDate"
($resultdate) = &GetNextDate($planneddate,$subscription)
.PP
this function is an extension of GetNextDate which allows for checking for irregularity
.PP
it takes the planneddate and will return the next issue's date and will skip dates if there
exists an irregularity
\&\- eg if periodicity is monthly and \f(CW$planneddate\fR is 2007\-02\-10 but if March and April is to be 
skipped then the returned date will be 2007\-05\-10
.PP
return :
\&\f(CW$resultdate\fR \- then next date in the sequence
.PP
Return 0 if periodicity==0
.SS "itemdata"
.IX Subsection "itemdata"
.Vb 1
\&  $item = &itemdata($barcode);
.Ve
.PP
Looks up the item with the given barcode, and returns a
reference-to-hash containing information about that item. The keys of
the hash are the fields from the \f(CW\*(C`items\*(C'\fR and \f(CW\*(C`biblioitems\*(C'\fR tables in
the Koha database.
.SH "AUTHOR"
.IX Header "AUTHOR"
Koha Developement team <info@koha.org>
