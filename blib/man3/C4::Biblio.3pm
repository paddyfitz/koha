.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "C4::Biblio 3"
.TH C4::Biblio 3 "2010-12-10" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Biblio \- cataloging management functions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Biblio.pm contains functions for managing storage and editing of bibliographic data within Koha. Most of the functions in this module are used for cataloging records: adding, editing, or removing biblios, biblioitems, or items. Koha's stores bibliographic information in three places:
.IP "1. in the biblio,biblioitems,items, etc tables, which are limited to a one-to-one mapping to underlying \s-1MARC\s0 data" 4
.IX Item "1. in the biblio,biblioitems,items, etc tables, which are limited to a one-to-one mapping to underlying MARC data"
.PD 0
.IP "2. as raw \s-1MARC\s0 in the Zebra index and storage engine" 4
.IX Item "2. as raw MARC in the Zebra index and storage engine"
.IP "3. as raw \s-1MARC\s0 the biblioitems.marc and biblioitems.marcxml" 4
.IX Item "3. as raw MARC the biblioitems.marc and biblioitems.marcxml"
.PD
.PP
In the 3.0 version of Koha, the authoritative record-level information is in biblioitems.marcxml
.PP
Because the data isn't completely normalized there's a chance for information to get out of sync. The design choice to go with a un-normalized schema was driven by performance and stability concerns. However, if this occur, it can be considered as a bug : The \s-1API\s0 is (or should be) complete & the only entry point for all biblio/items managements.
.IP "1. Compared with MySQL, Zebra is slow to update an index for small data changes \*(-- especially for proc-intensive operations like circulation" 4
.IX Item "1. Compared with MySQL, Zebra is slow to update an index for small data changes  especially for proc-intensive operations like circulation"
.PD 0
.IP "2. Zebra's index has been known to crash and a backup of the data is necessary to rebuild it in such cases" 4
.IX Item "2. Zebra's index has been known to crash and a backup of the data is necessary to rebuild it in such cases"
.PD
.PP
Because of this design choice, the process of managing storage and editing is a bit convoluted. Historically, Biblio.pm's grown to an unmanagable size and as a result we have several types of functions currently:
.IP "1. Add*/Mod*/Del*/ \- high-level external functions suitable for being called from external scripts to manage the collection" 4
.IX Item "1. Add*/Mod*/Del*/ - high-level external functions suitable for being called from external scripts to manage the collection"
.PD 0
.IP "2. _koha_* \- low-level internal functions for managing the koha tables" 4
.IX Item "2. _koha_* - low-level internal functions for managing the koha tables"
.IP "3. Marc management function : as the \s-1MARC\s0 record is stored in biblioitems.marc(xml), some subs dedicated to it's management are in this package. They should be used only internally by Biblio.pm, the only official entry points being AddBiblio, AddItem, ModBiblio, ModItem." 4
.IX Item "3. Marc management function : as the MARC record is stored in biblioitems.marc(xml), some subs dedicated to it's management are in this package. They should be used only internally by Biblio.pm, the only official entry points being AddBiblio, AddItem, ModBiblio, ModItem."
.IP "4. Zebra functions used to update the Zebra index" 4
.IX Item "4. Zebra functions used to update the Zebra index"
.IP "5. internal helper functions such as char_decode, checkitems, etc. Some of these probably belong in Koha.pm" 4
.IX Item "5. internal helper functions such as char_decode, checkitems, etc. Some of these probably belong in Koha.pm"
.PD
.PP
The \s-1MARC\s0 record (in biblioitems.marcxml) contains the complete marc record, including items. It also contains the biblionumber. That is the reason why it is not stored directly by AddBiblio, with all other fields . To save a biblio, we need to :
.IP "1. save datas in biblio and biblioitems table, that gives us a biblionumber and a biblioitemnumber" 4
.IX Item "1. save datas in biblio and biblioitems table, that gives us a biblionumber and a biblioitemnumber"
.PD 0
.IP "2. add the biblionumber and biblioitemnumber into the \s-1MARC\s0 records" 4
.IX Item "2. add the biblionumber and biblioitemnumber into the MARC records"
.IP "3. save the marc record" 4
.IX Item "3. save the marc record"
.PD
.PP
When dealing with items, we must :
.IP "1. save the item in items table, that gives us an itemnumber" 4
.IX Item "1. save the item in items table, that gives us an itemnumber"
.PD 0
.IP "2. add the itemnumber to the item \s-1MARC\s0 field" 4
.IX Item "2. add the itemnumber to the item MARC field"
.IP "3. overwrite the \s-1MARC\s0 record (with the added item) into biblioitems.marc(xml)" 4
.IX Item "3. overwrite the MARC record (with the added item) into biblioitems.marc(xml)"
.PD
When modifying a biblio or an item, the behaviour is quite similar.
.SH "EXPORTED FUNCTIONS"
.IX Header "EXPORTED FUNCTIONS"
.SS "AddBiblio"
.IX Subsection "AddBiblio"
.RS 4
($biblionumber,$biblioitemnumber) = AddBiblio($record,$frameworkcode);
.RE
.PP
Exported function (core \s-1API\s0) for adding a new biblio to koha.
.PP
The first argument is a \f(CW\*(C`MARC::Record\*(C'\fR object containing the
bib to add, while the second argument is the desired \s-1MARC\s0
framework code.
.PP
This function also accepts a third, optional argument: a hashref
to additional options.  The only defined option is \f(CW\*(C`defer_marc_save\*(C'\fR,
which if present and mapped to a true value, causes \f(CW\*(C`AddBiblio\*(C'\fR
to omit the call to save the \s-1MARC\s0 in \f(CW\*(C`bibilioitems.marc\*(C'\fR
and \f(CW\*(C`biblioitems.marcxml\*(C'\fR  This option is provided \fBonly\fR
for the use of scripts such as \f(CW\*(C`bulkmarcimport.pl\*(C'\fR that may need
to do some manipulation of the \s-1MARC\s0 record for item parsing before
saving it and which cannot afford the performance hit of saving
the \s-1MARC\s0 record twice.  Consequently, do not use that option
unless you can guarantee that \f(CW\*(C`ModBiblioMarc\*(C'\fR will be called.
.SS "ModBiblio"
.IX Subsection "ModBiblio"
.Vb 1
\&    ModBiblio( $record,$biblionumber,$frameworkcode);
.Ve
.PP
Replace an existing bib record identified by \f(CW$biblionumber\fR
with one supplied by the MARC::Record object \f(CW$record\fR.  The embedded
item, biblioitem, and biblionumber fields from the previous
version of the bib record replace any such fields of those tags that
are present in \f(CW$record\fR.  Consequently, \fIModBiblio()\fR is not
to be used to try to modify item records.
.PP
\&\f(CW$frameworkcode\fR specifies the \s-1MARC\s0 framework to use
when storing the modified bib record; among other things,
this controls how \s-1MARC\s0 fields get mapped to display columns
in the \f(CW\*(C`biblio\*(C'\fR and \f(CW\*(C`biblioitems\*(C'\fR tables, as well as
which fields are used to store embedded item, biblioitem,
and biblionumber data for indexing.
.SS "ModBiblioframework"
.IX Subsection "ModBiblioframework"
.Vb 2
\&    ModBiblioframework($biblionumber,$frameworkcode);
\&    Exported function to modify a biblio framework
.Ve
.SS "DelBiblio"
.IX Subsection "DelBiblio"
.RS 4
my \f(CW$error\fR = &DelBiblio($dbh,$biblionumber);
Exported function (core \s-1API\s0) for deleting a biblio in koha.
Deletes biblio record from Zebra and Koha tables (biblio,biblioitems,items)
Also backs it up to deleted* tables
Checks to make sure there are not issues on any of the items
return:
\&\f(CW$error\fR : undef unless an error occurs
.RE
.SS "LinkBibHeadingsToAuthorities"
.IX Subsection "LinkBibHeadingsToAuthorities"
.RS 4
my \f(CW$headings_linked\fR = LinkBibHeadingsToAuthorities($marc);
.RE
.PP
Links bib headings to authority records by checking
each authority-controlled field in the \f(CW\*(C`MARC::Record\*(C'\fR
object \f(CW$marc\fR, looking for a matching authority record,
and setting the linking subfield \f(CW$9\fR to the \s-1ID\s0 of that
authority record.
.PP
If no matching authority exists, or if multiple
authorities match, no \f(CW$9\fR will be added, and any 
existing one inthe field will be deleted.
.PP
Returns the number of heading links changed in the
\&\s-1MARC\s0 record.
.SS "GetRecordValue"
.IX Subsection "GetRecordValue"
.RS 4
my \f(CW$values\fR = GetRecordValue($field, \f(CW$record\fR, \f(CW$frameworkcode\fR);
.RE
.PP
Get \s-1MARC\s0 fields from a keyword defined in fieldmapping table.
.SS "SetFieldMapping"
.IX Subsection "SetFieldMapping"
.RS 4
SetFieldMapping($framework, \f(CW$field\fR, \f(CW$fieldcode\fR, \f(CW$subfieldcode\fR);
.RE
.PP
Set a Field to \s-1MARC\s0 mapping value, if it already exists we don't add a new one.
.SS "DeleteFieldMapping"
.IX Subsection "DeleteFieldMapping"
.RS 4
DeleteFieldMapping($id);
.RE
.PP
Delete a field mapping from an \f(CW$id\fR.
.SS "GetFieldMapping"
.IX Subsection "GetFieldMapping"
.RS 4
GetFieldMapping($frameworkcode);
.RE
.PP
Get all field mappings for a specified frameworkcode
.SS "GetBiblioData"
.IX Subsection "GetBiblioData"
.RS 4
\&\f(CW$data\fR = &GetBiblioData($biblionumber);
Returns information about the book with the given biblionumber.
\&\f(CW&GetBiblioData\fR returns a reference-to-hash. The keys are the fields in
the \f(CW\*(C`biblio\*(C'\fR and \f(CW\*(C`biblioitems\*(C'\fR tables in the
Koha database.
In addition, \f(CW\*(C`$data\->{subject}\*(C'\fR is the list of the book's
subjects, separated by \f(CW" , "\fR (space, comma, space).
If there are multiple biblioitems with the given biblionumber, only
the first one is considered.
.RE
.SS "&GetBiblioItemData"
.IX Subsection "&GetBiblioItemData"
.RS 4
\&\f(CW$itemdata\fR = &GetBiblioItemData($biblioitemnumber);
.Sp
Looks up the biblioitem with the given biblioitemnumber. Returns a
reference-to-hash. The keys are the fields from the \f(CW\*(C`biblio\*(C'\fR,
\&\f(CW\*(C`biblioitems\*(C'\fR, and \f(CW\*(C`itemtypes\*(C'\fR tables in the Koha database, except
that \f(CW\*(C`biblioitems.notes\*(C'\fR is given as \f(CW\*(C`$itemdata\->{bnotes}\*(C'\fR.
.RE
.SS "GetBiblioItemByBiblioNumber"
.IX Subsection "GetBiblioItemByBiblioNumber"
.RS 4
\&\s-1NOTE\s0 : This function has been copy/paste from C4/Biblio.pm from head before zebra integration.
.RE
.SS "GetBiblioFromItemNumber"
.IX Subsection "GetBiblioFromItemNumber"
.RS 4
\&\f(CW$item\fR = &GetBiblioFromItemNumber($itemnumber,$barcode);
.Sp
Looks up the item with the given itemnumber. if undef, try the barcode.
.Sp
\&\f(CW&itemnodata\fR returns a reference-to-hash whose keys are the fields
from the \f(CW\*(C`biblio\*(C'\fR, \f(CW\*(C`biblioitems\*(C'\fR, and \f(CW\*(C`items\*(C'\fR tables in the Koha
database.
.RE
.SS "GetISBDView"
.IX Subsection "GetISBDView"
.RS 4
\&\f(CW$isbd\fR = &GetISBDView($biblionumber);
.Sp
Return the \s-1ISBD\s0 view which can be included in opac and intranet
.RE
.SS "GetBiblio"
.IX Subsection "GetBiblio"
.RS 4
( \f(CW$count\fR, \f(CW@results\fR ) = &GetBiblio($biblionumber);
.RE
.SS "GetBiblioItemInfosOf"
.IX Subsection "GetBiblioItemInfosOf"
.RS 4
GetBiblioItemInfosOf(@biblioitemnumbers);
.RE
.SH "FUNCTIONS FOR HANDLING MARC MANAGEMENT"
.IX Header "FUNCTIONS FOR HANDLING MARC MANAGEMENT"
.SS "GetMarcStructure"
.IX Subsection "GetMarcStructure"
.RS 4
\&\f(CW$res\fR = GetMarcStructure($forlibrarian,$frameworkcode);
.Sp
Returns a reference to a big hash of hash, with the Marc structure for the given frameworkcode
\&\f(CW$forlibrarian\fR  :if set to 1, the \s-1MARC\s0 descriptions are the librarians ones, otherwise it's the public (\s-1OPAC\s0) ones
\&\f(CW$frameworkcode\fR : the framework code to read
.RE
.SS "GetUsedMarcStructure"
.IX Subsection "GetUsedMarcStructure"
.Vb 2
\&    the same function as GetMarcStructure except it just takes field
\&    in tab 0\-9. (used field)
\&    
\&    my $results = GetUsedMarcStructure($frameworkcode);
\&    
\&    L<$results> is a ref to an array which each case containts a ref
\&    to a hash which each keys is the columns from marc_subfield_structure
\&    
\&    L<$frameworkcode> is the framework code.
.Ve
.SS "GetMarcFromKohaField"
.IX Subsection "GetMarcFromKohaField"
.RS 4
($MARCfield,$MARCsubfield)=GetMarcFromKohaField($kohafield,$frameworkcode);
Returns the \s-1MARC\s0 fields & subfields mapped to the koha field 
for the given frameworkcode
.RE
.SS "GetMarcBiblio"
.IX Subsection "GetMarcBiblio"
.RS 4
my \f(CW$record\fR = GetMarcBiblio($biblionumber);
.RE
.PP
Returns MARC::Record representing bib identified by
\&\f(CW$biblionumber\fR.  If no bib exists, returns undef.
The \s-1MARC\s0 record contains both biblio & item data.
.SS "GetXmlBiblio"
.IX Subsection "GetXmlBiblio"
.RS 4
my \f(CW$marcxml\fR = GetXmlBiblio($biblionumber);
.Sp
Returns biblioitems.marcxml of the biblionumber passed in parameter.
The \s-1XML\s0 contains both biblio & item datas
.RE
.SS "GetCOinSBiblio"
.IX Subsection "GetCOinSBiblio"
.RS 4
my \f(CW$coins\fR = GetCOinSBiblio($biblionumber);
.Sp
Returns the COinS(a span) which can be included in a biblio record
.RE
.SS "GetBiblioSummary"
.IX Subsection "GetBiblioSummary"
.RS 4
\&\f(CW$summary\fR = GetBiblioSummary($marcrecord);
.Sp
Return the summary of a record.
.RE
.SS "GetAuthorisedValueDesc"
.IX Subsection "GetAuthorisedValueDesc"
.RS 4
my \f(CW$subfieldvalue\fR =get_authorised_value_desc(
    \f(CW$tag\fR, \f(CW$subf\fR[$i][0],$subf[$i][1], '', \f(CW$taglib\fR, \f(CW$category\fR);
Retrieve the complete description for a given authorised value.
.Sp
Now takes \f(CW$category\fR and \f(CW$value\fR pair too.
my \f(CW$auth_value_desc\fR =GetAuthorisedValueDesc(
    '','', '\s-1DVD\s0' ,'','','\s-1CCODE\s0');
.RE
.SS "GetMarcNotes"
.IX Subsection "GetMarcNotes"
.RS 4
\&\f(CW$marcnotesarray\fR = GetMarcNotes( \f(CW$record\fR, \f(CW$marcflavour\fR );
Get all notes from the \s-1MARC\s0 record and returns them in an array.
The note are stored in differents places depending on \s-1MARC\s0 flavour
.RE
.SS "GetMarcSubjects"
.IX Subsection "GetMarcSubjects"
.RS 4
\&\f(CW$marcsubjcts\fR = GetMarcSubjects($record,$marcflavour);
Get all subjects from the \s-1MARC\s0 record and returns them in an array.
The subjects are stored in differents places depending on \s-1MARC\s0 flavour
.RE
.SS "GetMarcAuthors"
.IX Subsection "GetMarcAuthors"
.RS 4
authors = GetMarcAuthors($record,$marcflavour);
Get all authors from the \s-1MARC\s0 record and returns them in an array.
The authors are stored in differents places depending on \s-1MARC\s0 flavour
.RE
.SS "GetMarcUrls"
.IX Subsection "GetMarcUrls"
.RS 4
\&\f(CW$marcurls\fR = GetMarcUrls($record,$marcflavour);
Returns arrayref of URLs from \s-1MARC\s0 data, suitable to pass to tmpl loop.
Assumes web resources (not uncommon in \s-1MARC21\s0 to omit resource type ind)
.RE
.SS "GetMarcSeries"
.IX Subsection "GetMarcSeries"
.RS 4
\&\f(CW$marcseriesarray\fR = GetMarcSeries($record,$marcflavour);
Get all series from the \s-1MARC\s0 record and returns them in an array.
The series are stored in differents places depending on \s-1MARC\s0 flavour
.RE
.SS "GetFrameworkCode"
.IX Subsection "GetFrameworkCode"
.Vb 1
\&    $frameworkcode = GetFrameworkCode( $biblionumber )
.Ve
.SS "GetPublisherNameFromIsbn"
.IX Subsection "GetPublisherNameFromIsbn"
.Vb 4
\&    $name = GetPublishercodeFromIsbn($isbn);
\&    if(defined $name){
\&        ...
\&    }
.Ve
.SS "TransformKohaToMarc"
.IX Subsection "TransformKohaToMarc"
.Vb 4
\&    $record = TransformKohaToMarc( $hash )
\&    This function builds partial MARC::Record from a hash
\&    Hash entries can be from biblio or biblioitems.
\&    This function is called in acquisition module, to create a basic catalogue entry from user entry
.Ve
.SS "TransformKohaToMarcOneField"
.IX Subsection "TransformKohaToMarcOneField"
.Vb 1
\&    $record = TransformKohaToMarcOneField( $sth, $record, $kohafieldname, $value, $frameworkcode );
.Ve
.SS "TransformHtmlToXml"
.IX Subsection "TransformHtmlToXml"
.RS 4
\&\f(CW$xml\fR = TransformHtmlToXml( \f(CW$tags\fR, \f(CW$subfields\fR, \f(CW$values\fR, \f(CW$indicator\fR, \f(CW$ind_tag\fR, \f(CW$auth_type\fR )
.Sp
\&\f(CW$auth_type\fR contains :
\&\- nothing : rebuild a biblio, un \s-1UNIMARC\s0 the encoding is in 100$a pos 26/27
\&\- \s-1UNIMARCAUTH\s0 : rebuild an authority. In \s-1UNIMARC\s0, the encoding is in 100$a pos 13/14
\&\- \s-1ITEM\s0 : rebuild an item : in \s-1UNIMARC\s0, 100$a, it's in the biblio ! (otherwise, we would get 2 100 fields !)
.RE
.SS "_default_ind_to_space"
.IX Subsection "_default_ind_to_space"
Passed what should be an indicator returns a space
if its undefined or zero length
.SS "TransformHtmlToMarc"
.IX Subsection "TransformHtmlToMarc"
.Vb 10
\&    L<$record> = TransformHtmlToMarc(L<$params>,L<$cgi>)
\&    L<$params> is a ref to an array as below:
\&    {
\&        \*(Aqtag_010_indicator1_531951\*(Aq ,
\&        \*(Aqtag_010_indicator2_531951\*(Aq ,
\&        \*(Aqtag_010_code_a_531951_145735\*(Aq ,
\&        \*(Aqtag_010_subfield_a_531951_145735\*(Aq ,
\&        \*(Aqtag_200_indicator1_873510\*(Aq ,
\&        \*(Aqtag_200_indicator2_873510\*(Aq ,
\&        \*(Aqtag_200_code_a_873510_673465\*(Aq ,
\&        \*(Aqtag_200_subfield_a_873510_673465\*(Aq ,
\&        \*(Aqtag_200_code_b_873510_704318\*(Aq ,
\&        \*(Aqtag_200_subfield_b_873510_704318\*(Aq ,
\&        \*(Aqtag_200_code_e_873510_280822\*(Aq ,
\&        \*(Aqtag_200_subfield_e_873510_280822\*(Aq ,
\&        \*(Aqtag_200_code_f_873510_110730\*(Aq ,
\&        \*(Aqtag_200_subfield_f_873510_110730\*(Aq ,
\&    }
\&    L<$cgi> is the CGI object which containts the value.
\&    L<$record> is the MARC::Record object.
.Ve
.SS "TransformMarcToKoha"
.IX Subsection "TransformMarcToKoha"
.Vb 1
\&    $result = TransformMarcToKoha( $dbh, $record, $frameworkcode )
.Ve
.PP
Extract data from a \s-1MARC\s0 bib record into a hashref representing
Koha biblio, biblioitems, and items fields.
.SS "_disambiguate"
.IX Subsection "_disambiguate"
.RS 4
\&\f(CW$newkey\fR = _disambiguate($table, \f(CW$field\fR);
.Sp
This is a temporary hack to distinguish between the
following sets of columns when using TransformMarcToKoha.
.Sp
items.cn_source & biblioitems.cn_source
items.cn_sort & biblioitems.cn_sort
.Sp
Columns that are currently \s-1NOT\s0 distinguished (\s-1FIXME\s0
due to lack of time to fully test) are:
.Sp
biblio.notes and biblioitems.notes
biblionumber
timestamp
biblioitemnumber
.Sp
\&\s-1FIXME\s0 \- this is necessary because prefixing each column
name with the table name would require changing lots
of code and templates, and exposing more of the \s-1DB\s0
structure than is good to the \s-1UI\s0 templates, particularly
since biblio and bibloitems may well merge in a future
version.  In the future, it would also be good to 
separate \s-1DB\s0 access and \s-1UI\s0 presentation field names
more.
.RE
.SS "get_koha_field_from_marc"
.IX Subsection "get_koha_field_from_marc"
.RS 4
\&\f(CW$result\fR\->{_disambiguate($table, \f(CW$field\fR)} = get_koha_field_from_marc($table,$field,$record,$frameworkcode);
.Sp
Internal function to map data from the \s-1MARC\s0 record to a specific non-MARC field.
\&\s-1FIXME:\s0 this is meant to replace TransformMarcToKohaOneField after more testing.
.RE
.SS "TransformMarcToKohaOneField"
.IX Subsection "TransformMarcToKohaOneField"
.RS 4
\&\f(CW$result\fR = TransformMarcToKohaOneField( \f(CW$kohatable\fR, \f(CW$kohafield\fR, \f(CW$record\fR, \f(CW$result\fR, \f(CW$frameworkcode\fR )
.RE
.SH "OTHER FUNCTIONS"
.IX Header "OTHER FUNCTIONS"
.SS "PrepareItemrecordDisplay"
.IX Subsection "PrepareItemrecordDisplay"
.RS 4
PrepareItemrecordDisplay($itemrecord,$bibnum,$itemumber);
.Sp
Returns a hash with all the fields for Display a given item data in a template
.RE
.SS "ModZebra"
.IX Subsection "ModZebra"
.RS 4
ModZebra( \f(CW$biblionumber\fR, \f(CW$op\fR, \f(CW$server\fR, \f(CW$oldRecord\fR, \f(CW$newRecord\fR );
.Sp
.Vb 7
\&    $biblionumber is the biblionumber we want to index
\&    $op is specialUpdate or delete, and is used to know what we want to do
\&    $server is the server that we want to update
\&    $oldRecord is the MARC::Record containing the previous version of the record.  This is used only when 
\&      NoZebra=1, as NoZebra indexing needs to know the previous version of a record in order to
\&      do an update.
\&    $newRecord is the MARC::Record containing the new record. It is usefull only when NoZebra=1, and is used to know what to add to the nozebra database. (the record in mySQL being, if it exist, the previous record, the one just before the modif. We need both : the previous and the new one.
.Ve
.RE
.SS "GetNoZebraIndexes"
.IX Subsection "GetNoZebraIndexes"
.Vb 1
\&    %indexes = GetNoZebraIndexes;
\&    
\&    return the data from NoZebraIndexes syspref.
.Ve
.SH "INTERNAL FUNCTIONS"
.IX Header "INTERNAL FUNCTIONS"
.SS "_DelBiblioNoZebra($biblionumber,$record,$server);"
.IX Subsection "_DelBiblioNoZebra($biblionumber,$record,$server);"
.Vb 7
\&    function to delete a biblio in NoZebra indexes
\&    This function does NOT delete anything in database : it reads all the indexes entries
\&    that have to be deleted & delete them in the hash
\&    The SQL part is done either :
\&    \- after the Add if we are modifying a biblio (delete + add again)
\&    \- immediatly after this sub if we are doing a true deletion.
\&    $server can be \*(Aqbiblioserver\*(Aq or \*(Aqauthorityserver\*(Aq : it indexes biblios or authorities (in the same table, $server being part of the table itself
.Ve
.ie n .SS "_AddBiblioNoZebra($biblionumber, $record, $server, %result);"
.el .SS "_AddBiblioNoZebra($biblionumber, \f(CW$record\fP, \f(CW$server\fP, \f(CW%result\fP);"
.IX Subsection "_AddBiblioNoZebra($biblionumber, $record, $server, %result);"
.Vb 1
\&    function to add a biblio in NoZebra indexes
.Ve
.SS "_find_value"
.IX Subsection "_find_value"
.RS 4
($indicators, \f(CW$value\fR) = _find_value($tag, \f(CW$subfield\fR, \f(CW$record\fR,$encoding);
.Sp
Find the given \f(CW$subfield\fR in the given \f(CW$tag\fR in the given
MARC::Record \f(CW$record\fR.  If the subfield is found, returns
the (indicators, value) pair; otherwise, (undef, undef) is
returned.
.Sp
\&\s-1PROPOSITION\s0 :
Such a function is used in addbiblio \s-1AND\s0 additem and serial-edit and maybe could be used in Authorities.
I suggest we export it from this module.
.RE
.SS "_koha_marc_update_bib_ids"
.IX Subsection "_koha_marc_update_bib_ids"
.RS 4
_koha_marc_update_bib_ids($record, \f(CW$frameworkcode\fR, \f(CW$biblionumber\fR, \f(CW$biblioitemnumber\fR);
.Sp
Internal function to add or update biblionumber and biblioitemnumber to
the \s-1MARC\s0 \s-1XML\s0.
.RE
.SS "_koha_marc_update_biblioitem_cn_sort"
.IX Subsection "_koha_marc_update_biblioitem_cn_sort"
.RS 4
_koha_marc_update_biblioitem_cn_sort($marc, \f(CW$biblioitem\fR, \f(CW$frameworkcode\fR);
.RE
.PP
Given a \s-1MARC\s0 bib record and the biblioitem hash, update the
subfield that contains a copy of the value of biblioitems.cn_sort.
.SS "_koha_add_biblio"
.IX Subsection "_koha_add_biblio"
.RS 4
my ($biblionumber,$error) = _koha_add_biblio($dbh,$biblioitem);
.Sp
Internal function to add a biblio ($biblio is a hash with the values)
.RE
.SS "_koha_modify_biblio"
.IX Subsection "_koha_modify_biblio"
.RS 4
my ($biblionumber,$error) == _koha_modify_biblio($dbh,$biblio,$frameworkcode);
.Sp
Internal function for updating the biblio table
.RE
.SS "_koha_modify_biblioitem_nonmarc"
.IX Subsection "_koha_modify_biblioitem_nonmarc"
.RS 4
my ($biblioitemnumber,$error) = _koha_modify_biblioitem_nonmarc( \f(CW$dbh\fR, \f(CW$biblioitem\fR );
.Sp
Updates biblioitems row except for marc and marcxml, which should be changed
via ModBiblioMarc
.RE
.SS "_koha_add_biblioitem"
.IX Subsection "_koha_add_biblioitem"
.RS 4
my ($biblioitemnumber,$error) = _koha_add_biblioitem( \f(CW$dbh\fR, \f(CW$biblioitem\fR );
.Sp
Internal function to add a biblioitem
.RE
.SS "_koha_delete_biblio"
.IX Subsection "_koha_delete_biblio"
.RS 4
\&\f(CW$error\fR = _koha_delete_biblio($dbh,$biblionumber);
.Sp
Internal sub for deleting from biblio table \*(-- also saves to deletedbiblio
.Sp
\&\f(CW$dbh\fR \- the database handle
\&\f(CW$biblionumber\fR \- the biblionumber of the biblio to be deleted
.RE
.SS "_koha_delete_biblioitems"
.IX Subsection "_koha_delete_biblioitems"
.RS 4
\&\f(CW$error\fR = _koha_delete_biblioitems($dbh,$biblioitemnumber);
.Sp
Internal sub for deleting from biblioitems table \*(-- also saves to deletedbiblioitems
.Sp
\&\f(CW$dbh\fR \- the database handle
\&\f(CW$biblionumber\fR \- the biblioitemnumber of the biblioitem to be deleted
.RE
.SH "UNEXPORTED FUNCTIONS"
.IX Header "UNEXPORTED FUNCTIONS"
.SS "ModBiblioMarc"
.IX Subsection "ModBiblioMarc"
.Vb 1
\&    &ModBiblioMarc($newrec,$biblionumber,$frameworkcode);
\&    
\&    Add MARC data for a biblio to koha 
\&    
\&    Function exported, but should NOT be used, unless you really know what you\*(Aqre doing
.Ve
.SS "z3950_extended_services"
.IX Subsection "z3950_extended_services"
z3950_extended_services($serviceType,$serviceOptions,$record);
.PP
.Vb 1
\&    z3950_extended_services is used to handle all interactions with Zebra\*(Aqs extended serices package, which is employed to perform all management of the MARC data stored in Zebra.
.Ve
.PP
\&\f(CW$serviceType\fR one of: itemorder,create,drop,commit,update,xmlupdate
.PP
\&\f(CW$serviceOptions\fR a has of key/value pairs. For instance, if service_type is 'update', \f(CW$service_options\fR should contain:
.PP
.Vb 1
\&    action => update action, one of specialUpdate, recordInsert, recordReplace, recordDelete, elementUpdate.
.Ve
.PP
and maybe
.PP
.Vb 3
\&    recordidOpaque => Opaque Record ID (user supplied) or recordidNumber => Record ID number (system number).
\&    syntax => the record syntax (transfer syntax)
\&    databaseName = Database from connection object
\&
\&    To set serviceOptions, call set_service_options($serviceType)
.Ve
.PP
\&\f(CW$record\fR the record, if one is needed for the service type
.PP
.Vb 1
\&    A record should be in XML. You can convert it to XML from MARC by running it through marc2xml().
.Ve
.SS "set_service_options"
.IX Subsection "set_service_options"
my \f(CW$serviceOptions\fR = set_service_options($serviceType);
.PP
\&\f(CW$serviceType\fR itemorder,create,drop,commit,update,xmlupdate
.PP
Currently, we only support 'create', 'commit', and 'update'. 'drop' support will be added as soon as Zebra supports it.
.PP
\fIget_biblio_authorised_values\fR
.IX Subsection "get_biblio_authorised_values"
.PP
.Vb 1
\&  find the types and values for all authorised values assigned to this biblio.
\&
\&  parameters:
\&    biblionumber
\&    MARC::Record of the bib
\&
\&  returns: a hashref mapping the authorised value to the value set for this biblionumber
\&
\&      $authorised_values = {
\&                             \*(AqScent\*(Aq     => \*(Aqflowery\*(Aq,
\&                             \*(AqAudience\*(Aq  => \*(AqYoung Adult\*(Aq,
\&                             \*(Aqitemtypes\*(Aq => \*(AqSER\*(Aq,
\&                           };
\&
\&  Notes: forlibrarian should probably be passed in, and called something different.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Koha Developement team <info@koha.org>
.PP
Paul \s-1POULAIN\s0 paul.poulain@free.fr
.PP
Joshua Ferraro jmf@liblime.com
