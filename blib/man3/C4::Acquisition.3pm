.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "C4::Acquisition 3"
.TH C4::Acquisition 3 "2010-12-10" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
C4::Acquisition \- Koha functions for dealing with orders and acquisitions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use C4::Acquisition;
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The functions in this module deal with acquisitions, managing book
orders, basket and parcels.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "\s-1FUNCTIONS\s0 \s-1ABOUT\s0 \s-1BASKETS\s0"
.IX Subsection "FUNCTIONS ABOUT BASKETS"
\fIGetBasket\fR
.IX Subsection "GetBasket"
.Sp
.RS 4
\&\f(CW$aqbasket\fR = &GetBasket($basketnumber);
.Sp
get all basket informations in aqbasket for a given basket
.Sp
return :
informations for a given basket returned as a hashref.
.RE
.PP
\fINewBasket\fR
.IX Subsection "NewBasket"
.Sp
.RS 4
\&\f(CW$basket\fR = &\fINewBasket()\fR;
.Sp
Create a new basket in aqbasket table
.RE
.PP
\fICloseBasket\fR
.IX Subsection "CloseBasket"
.Sp
.RS 4
&CloseBasket($basketno);
.Sp
close a basket (becomes unmodifiable,except for recieves)
.RE
.SS "\s-1FUNCTIONS\s0 \s-1ABOUT\s0 \s-1ORDERS\s0"
.IX Subsection "FUNCTIONS ABOUT ORDERS"
\fIGetPendingOrders\fR
.IX Subsection "GetPendingOrders"
.Sp
.RS 4
\&\f(CW$orders\fR = &GetPendingOrders($booksellerid, \f(CW$grouped\fR);
.Sp
Finds pending orders from the bookseller with the given \s-1ID\s0. Ignores
completed and cancelled orders.
.Sp
\&\f(CW$orders\fR is a reference-to-array; each element is a
reference-to-hash with the following fields:
\&\f(CW$grouped\fR is a boolean that, if set to 1 will group all order lines of the same basket
in a single result line
.ie n .IP """authorizedby""" 2
.el .IP "\f(CWauthorizedby\fR" 2
.IX Item "authorizedby"
.PD 0
.ie n .IP """entrydate""" 2
.el .IP "\f(CWentrydate\fR" 2
.IX Item "entrydate"
.ie n .IP """basketno""" 2
.el .IP "\f(CWbasketno\fR" 2
.IX Item "basketno"
.PD
These give the value of the corresponding field in the aqorders table
of the Koha database.
.RE
.RS 4
.RE
.PP
Results are ordered from most to least recent.
.PP
\fIGetOrders\fR
.IX Subsection "GetOrders"
.Sp
.RS 4
\&\f(CW@orders\fR = &GetOrders($basketnumber, \f(CW$orderby\fR);
.Sp
Looks up the pending (non-cancelled) orders with the given basket
number. If \f(CW$booksellerID\fR is non-empty, only orders from that seller
are returned.
.Sp
return :
\&\f(CW&basket\fR returns a two-element array. \f(CW@orders\fR is an array of
references-to-hash, whose keys are the fields from the aqorders,
biblio, and biblioitems tables in the Koha database.
.RE
.PP
\fIGetOrderNumber\fR
.IX Subsection "GetOrderNumber"
.Sp
.RS 4
\&\f(CW$ordernumber\fR = &GetOrderNumber($biblioitemnumber, \f(CW$biblionumber\fR);
.RE
.PP
Looks up the ordernumber with the given biblionumber and biblioitemnumber.
.PP
Returns the number of this order.
.ie n .IP "$ordernumber is the order number." 4
.el .IP "\f(CW$ordernumber\fR is the order number." 4
.IX Item "$ordernumber is the order number."
.PP
\fIGetOrder\fR
.IX Subsection "GetOrder"
.Sp
.RS 4
\&\f(CW$order\fR = &GetOrder($ordernumber);
.Sp
Looks up an order by order number.
.Sp
Returns a reference-to-hash describing the order. The keys of
\&\f(CW$order\fR are fields from the biblio, biblioitems, aqorders, and
aqorderbreakdown tables of the Koha database.
.RE
.PP
\fINewOrder\fR
.IX Subsection "NewOrder"
.Sp
.Vb 4
\&  &NewOrder($basket, $biblionumber, $title, $quantity, $listprice,
\&    $booksellerid, $who, $notes, $bookfund, $biblioitemnumber, $rrp,
\&    $ecost, $gst, $budget, $unitprice, $subscription,
\&    $booksellerinvoicenumber, $purchaseorder, $branchcode);
.Ve
.Sp
.RS 4
Adds a new order to the database. Any argument that isn't described
below is the new value of the field with the same name in the aqorders
table of the Koha database.
.Sp
\&\f(CW$ordnum\fR is a \*(L"minimum order number.\*(R" After adding the new entry to
the aqorders table, \f(CW&neworder\fR finds the first entry in aqorders
with order number greater than or equal to \f(CW$ordnum\fR, and adds an
entry to the aqorderbreakdown table, with the order number just found,
and the book fund \s-1ID\s0 of the newly-added order.
.Sp
\&\f(CW$budget\fR is effectively ignored.
  If it's undef (anything false) or the string 'now', the current day is used.
  Else, the upcoming July 1st is used.
.Sp
\&\f(CW$subscription\fR may be either \*(L"yes\*(R", or anything else for \*(L"no\*(R".
.RE
.PP
\fIModOrder\fR
.IX Subsection "ModOrder"
.Sp
.RS 4
&ModOrder($title, \f(CW$ordernumber\fR, \f(CW$quantity\fR, \f(CW$listprice\fR,
    \f(CW$biblionumber\fR, \f(CW$basketno\fR, \f(CW$supplier\fR, \f(CW$who\fR, \f(CW$notes\fR,
    \f(CW$bookfundid\fR, \f(CW$bibitemnum\fR, \f(CW$rrp\fR, \f(CW$ecost\fR, \f(CW$gst\fR, \f(CW$budget\fR,
    \f(CW$unitprice\fR, \f(CW$booksellerinvoicenumber\fR, \f(CW$branchcode\fR);
.Sp
Modifies an existing order. Updates the order with order number
\&\f(CW$ordernumber\fR and biblionumber \f(CW$biblionumber\fR. All other arguments
update the fields with the same name in the aqorders table of the Koha
database.
.Sp
Entries with order number \f(CW$ordernumber\fR in the aqorderbreakdown
table are also updated to the new book fund \s-1ID\s0 or branchcode.
.RE
.PP
\fIModOrderBiblioNumber\fR
.IX Subsection "ModOrderBiblioNumber"
.Sp
.RS 4
&ModOrderBiblioNumber($biblioitemnumber,$ordnum, \f(CW$biblionumber\fR);
.Sp
Modifies the biblioitemnumber for an existing order.
Updates the order with order number \f(CW$ordernum\fR and biblionumber \f(CW$biblionumber\fR.
.RE
.PP
\fIModReceiveOrder\fR
.IX Subsection "ModReceiveOrder"
.Sp
.RS 4
&ModReceiveOrder($biblionumber, \f(CW$ordernumber\fR, \f(CW$quantityreceived\fR, \f(CW$user\fR,
    \f(CW$unitprice\fR, \f(CW$booksellerinvoicenumber\fR, \f(CW$biblioitemnumber\fR,
    \f(CW$freight\fR, \f(CW$bookfund\fR, \f(CW$rrp\fR);
.Sp
Updates an order, to reflect the fact that it was received, at least
in part. All arguments not mentioned below update the fields with the
same name in the aqorders table of the Koha database.
.Sp
If a partial order is received, splits the order into two.  The received
portion must have a booksellerinvoicenumber.
.Sp
Updates the order with bibilionumber \f(CW$biblionumber\fR and ordernumber
\&\f(CW$ordernumber\fR.
.Sp
Also updates the book fund \s-1ID\s0 in the aqorderbreakdown table.
.RE
.PP
\fISearchOrder\fR
.IX Subsection "SearchOrder"
.PP
\&\f(CW@results\fR = &SearchOrder($search, \f(CW$biblionumber\fR, \f(CW$complete\fR);
.PP
Searches for orders.
.PP
\&\f(CW$search\fR may take one of several forms: if it is an \s-1ISBN\s0,
\&\f(CW&ordersearch\fR returns orders with that \s-1ISBN\s0. If \f(CW$search\fR is an
order number, \f(CW&ordersearch\fR returns orders with that order number
and biblionumber \f(CW$biblionumber\fR. Otherwise, \f(CW$search\fR is considered
to be a space-separated list of search terms; in this case, all of the
terms must appear in the title (matching the beginning of title
words).
.PP
If \f(CW$complete\fR is \f(CW\*(C`yes\*(C'\fR, the results will include only completed
orders. In any case, \f(CW&ordersearch\fR ignores cancelled orders.
.PP
\&\f(CW&ordersearch\fR returns an array.
\&\f(CW@results\fR is an array of references-to-hash with the following keys:
.ie n .IP """author""" 4
.el .IP "\f(CWauthor\fR" 4
.IX Item "author"
.PD 0
.ie n .IP """seriestitle""" 4
.el .IP "\f(CWseriestitle\fR" 4
.IX Item "seriestitle"
.ie n .IP """branchcode""" 4
.el .IP "\f(CWbranchcode\fR" 4
.IX Item "branchcode"
.ie n .IP """bookfundid""" 4
.el .IP "\f(CWbookfundid\fR" 4
.IX Item "bookfundid"
.PD
.PP
\fIDelOrder\fR
.IX Subsection "DelOrder"
.Sp
.RS 4
&DelOrder($biblionumber, \f(CW$ordernumber\fR);
.Sp
Cancel the order with the given order and biblio numbers. It does not
delete any entries in the aqorders table, it merely marks them as
cancelled.
.RE
.SS "\s-1FUNCTIONS\s0 \s-1ABOUT\s0 \s-1PARCELS\s0"
.IX Subsection "FUNCTIONS ABOUT PARCELS"
\fIGetParcel\fR
.IX Subsection "GetParcel"
.Sp
.RS 4
\&\f(CW@results\fR = &GetParcel($booksellerid, \f(CW$code\fR, \f(CW$date\fR);
.Sp
Looks up all of the received items from the supplier with the given
bookseller \s-1ID\s0 at the given date, for the given code (bookseller Invoice number). Ignores cancelled and completed orders.
.Sp
\&\f(CW@results\fR is an array of references-to-hash. The keys of each element are fields from
the aqorders, biblio, and biblioitems tables of the Koha database.
.Sp
\&\f(CW@results\fR is sorted alphabetically by book title.
.RE
.PP
\fIGetParcels\fR
.IX Subsection "GetParcels"
.Sp
.RS 4
\&\f(CW$results\fR = &GetParcels($bookseller, \f(CW$order\fR, \f(CW$code\fR, \f(CW$datefrom\fR, \f(CW$dateto\fR);
get a lists of parcels.
.RE
.PP
* Input arg :
.ie n .IP "$bookseller is the bookseller this function has to get parcels." 4
.el .IP "\f(CW$bookseller\fR is the bookseller this function has to get parcels." 4
.IX Item "$bookseller is the bookseller this function has to get parcels."
.PD 0
.ie n .IP "$order To know on what criteria the results list has to be ordered." 4
.el .IP "\f(CW$order\fR To know on what criteria the results list has to be ordered." 4
.IX Item "$order To know on what criteria the results list has to be ordered."
.ie n .IP "$code is the booksellerinvoicenumber." 4
.el .IP "\f(CW$code\fR is the booksellerinvoicenumber." 4
.IX Item "$code is the booksellerinvoicenumber."
.ie n .IP "$datefrom & $dateto to know on what date this function has to filter its search." 4
.el .IP "\f(CW$datefrom\fR & \f(CW$dateto\fR to know on what date this function has to filter its search." 4
.IX Item "$datefrom & $dateto to know on what date this function has to filter its search."
.PD
* return:
a pointer on a hash list containing parcel informations as such :
.IP "Creation date" 4
.IX Item "Creation date"
.PD 0
.IP "Last operation" 4
.IX Item "Last operation"
.IP "Number of biblio" 4
.IX Item "Number of biblio"
.IP "Number of items" 4
.IX Item "Number of items"
.PD
.PP
\fIGetLateOrders\fR
.IX Subsection "GetLateOrders"
.Sp
.RS 4
\&\f(CW@results\fR = &GetLateOrders;
.Sp
Searches for bookseller with late orders.
.Sp
return:
the table of supplier with late issues. This table is full of hashref.
.RE
.PP
\fIGetHistory\fR
.IX Subsection "GetHistory"
.Sp
.RS 4
(\e@order_loop, \f(CW$total_qty\fR, \f(CW$total_price\fR, \f(CW$total_qtyreceived\fR) = GetHistory( \f(CW$title\fR, \f(CW$author\fR, \f(CW$name\fR, \f(CW$from_placed_on\fR, \f(CW$to_placed_on\fR );
.Sp
.Vb 1
\&  Retreives some acquisition history information
\&
\&  returns:
\&    $order_loop is a list of hashrefs that each look like this:
\&              {
\&                \*(Aqauthor\*(Aq           => \*(AqTwain, Mark\*(Aq,
\&                \*(Aqbasketno\*(Aq         => \*(Aq1\*(Aq,
\&                \*(Aqbiblionumber\*(Aq     => \*(Aq215\*(Aq,
\&                \*(Aqcount\*(Aq            => 1,
\&                \*(Aqcreationdate\*(Aq     => \*(AqMM/DD/YYYY\*(Aq,
\&                \*(Aqdatereceived\*(Aq     => undef,
\&                \*(Aqecost\*(Aq            => \*(Aq1.00\*(Aq,
\&                \*(Aqid\*(Aq               => \*(Aq1\*(Aq,
\&                \*(Aqinvoicenumber\*(Aq    => undef,
\&                \*(Aqname\*(Aq             => \*(Aq\*(Aq,
\&                \*(Aqordernumber\*(Aq      => \*(Aq1\*(Aq,
\&                \*(Aqquantity\*(Aq         => 1,
\&                \*(Aqquantityreceived\*(Aq => undef,
\&                \*(Aqtitle\*(Aq            => \*(AqThe Adventures of Huckleberry Finn\*(Aq
\&              }
\&    $total_qty is the sum of all of the quantities in $order_loop
\&    $total_price is the cost of each in $order_loop times the quantity
\&    $total_qtyreceived is the sum of all of the quantityreceived entries in $order_loop
.Ve
.RE
.SS "GetRecentAcqui"
.IX Subsection "GetRecentAcqui"
.Vb 1
\&   $results = GetRecentAcqui($days);
\&
\&   C<$results> is a ref to a table which containts hashref
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Koha Developement team <info@koha.org>
